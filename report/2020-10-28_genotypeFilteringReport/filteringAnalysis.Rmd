---
title: "Genotype inference analysis"
author: "Ruth GÃ³mez Graciani"
output:
  bookdown::pdf_document2:
    toc: false
header-includes:
  \usepackage{float}
  \floatplacement{figure}{H}
---

_In this report, I put together IMPUTE2 results, genotypes inferred from tag SNPs and a coverage analysis to elaborte a definitive dataset of inversions reliably genotyped in as much individuals as possible from the 20 originally available. Those inversions genotyped in more than 3 individuals with at least 1 heterozygous and 1 homozygous sample will be used in later analyses. _

```{r, include=FALSE}

require("reshape2")
library("ggplot2")
library("kableExtra")

```

# IMPUTE2 results

```{r, include=FALSE}

# LOAD DATA
input.invs<-read.table("../../data/use/inversions_info/Inversions_imputability.txt", header = TRUE, stringsAsFactors = F)
coord.invs<-read.table("../../data/use/inversions_info/Inversions_coordinates_hg19.csv", col.names = c("Inversion", "chromosome", "B1s19", "B1e19", "B2s19", "B2e19"), stringsAsFactors = F)

# MERGE DATA
invs<- merge(coord.invs[, c("Inversion", "chromosome")], input.invs , all = TRUE, by = "Inversion")

# FILTER AUTOSOMAL IMPUTABLE
# Autosomal
invs<-invs[!(invs$chromosome %in% c("chrX", "chrY")),] 
# Imputable
accepted_tags<-c("Tagged", "Imputable", "No_Polymorphic")
invs <- invs[(invs$GLB %in% accepted_tags | invs$EUR %in% accepted_tags | invs$AFR %in% accepted_tags) ,]

# GREP invs with 3 options due to DEL genotype
amount_delinvs<-nrow(invs[grep( ".*id$", invs$Inversion),])

```


We had `r nrow(input.invs) - (amount_delinvs*2)` inversions with imputability information. The imputability information was available for GLB, AFR and EUR populations, and each inversion was marked as "No_Imputable", "Tagged", "Imputable" or "No_Polymorphic" (example in Table  \@ref(tab:imputability)). From this dataset, **`r nrow(invs)-(amount_delinvs*2)` inversions were autosomal and imputable** (i.e. "Tagged", "Imputable" or "No_Polymorphic" in at least 1 population). 

```{r imputability, echo =FALSE}

# Show

 kbl(head(input.invs,3), booktabs = T, row.names = FALSE, caption = "Example rows from the imputability information table", position = "h") %>%
  kable_styling(position = "center")

```

Since we don't have have measurements about how well does IMPUTE2 predict inversion orientations in EAS, SAS and ALL (admixed) individuals, the imputation process was repeated for each inversion and individual multiple times using different reference panels: same population haplotypes when possible (as control), and the 500, 250 and 100 closest haplotypes from the general population. This way, general population results can be used to (1) double check control results in EAS and SAS populations, where we don't know how reliable is IMPUTE2, and (2) predict orientation when same-population control results are not available. SNPs within the inversion region + 500kb to each side were used. 

The resulting table shows, for each inversion and individual, one Genotype and one Probability column for each reference panel that was used, marked as _con, _500, _250 and _100 to tell them apart (example in Table \@ref(tab:impute2)).

```{r impute2, echo =FALSE}

 # Individual genotypes
   # Get individuals genotypes
    genotypes<-read.table("../../analysis/2021-01-11_07_imputationTables/imputationResults.csv", header=TRUE, sep = ",", stringsAsFactors = FALSE)
  
    # Get individual names
    genotypes$Individual<-sub("^\\d+\\.","",genotypes$Individual)
    genotypes$Individual<-sub("nc", "NC", genotypes$Individual, ignore.case = FALSE)
    genotypes$Individual<-sub("ab", "", genotypes$Individual, ignore.case = FALSE)

    genotypes$Quality<-genotypes$Uniformity<- genotypes$EUR<-genotypes$AFR<-genotypes$GLB<-NULL
    
    # Show
    kbl(head(genotypes[,c(1:8)]), booktabs=T, row.names = FALSE, caption = "Some example rows from IMPUTE2 results table. Only some of the Probability and Genotype columns are present in this example.", position = "h")%>%
      kable_styling(position = "center", font_size = 7)
    
    # Merge with  imputation info
    genotypes<-merge(genotypes, input.invs, by = "Inversion")
 
    
```

Three columns were incorporated to this table, that help us decide how reliable each imputation result is. 

* **Imputability:** This column contains the population-specific imputability information relevant to this inversion and individual, obtained from the imputability information table (example in Table \@ref(tab:imputability)). EUR and AFR individuals will have the information from their corresponding columns and SAS, ALL and EAS individuals from the GLB column. 

* **Imp.min.probability:** For a predicted genotype to be considered we'll require a minimum probability value of 0.8. When there are Probability_con measurements, we'll only take those into account, because we trust same-population measurements more than whole population measurements. If this value is NULL due to a lack of samples in the reference panel, which happens in most ALL and SAS individuals but with some EAS individuals as well, all the remaining results (Probability_500, _250 and _100) will be required to meet the criteria. Thus, the Imp.min.quality (imputation minimum probability) column contains either the Probability_con value or the minimum value from Probability_500, _250 and _100 columns. 

* **Imp.all.equal:** This column contains TRUE/FALSE values indicating the consistency of imputation results. All genotypes for EUR and AFR individuals contain automatically a TRUE value, because we will consider the same population control only. Other populations' genotypes have a TRUE value when all their predicted genotypes are equal. All 4 measurements are available for most EAS individuals, and many of the inversions did not have a Genotype_con result in SAS and ALL individuals. 

```{r, include = FALSE}

# Now I apply one by one the filters to make sure they are correct

# STEP01: imputability 
genotypes$Imputability<-NA
genotypes[genotypes$Population %in% c("SAS", "ALL", "EAS"), "Imputability"]<-genotypes[genotypes$Population %in% c("SAS", "ALL", "EAS"), "GLB"]
genotypes[genotypes$Population %in% c("AFR"), "Imputability"]<-genotypes[genotypes$Population %in% c("AFR"), "AFR"]
genotypes[genotypes$Population %in% c("EUR"), "Imputability"]<-genotypes[genotypes$Population %in% c("EUR"), "EUR"]
    
# STEP02: quality
genotypes$Imp.min.quality<-apply(genotypes, 1, function(x){
  if (is.na(x["Probability_con"])){
    min( c( x["Probability_100"], x["Probability_250"], x["Probability_500"]))
  }else{
    x["Probability_con"]
  }
})

# STEP03: uniformity
genotypes$Imp.all.equal<-FALSE
genotypes[genotypes$Population %in% c("EUR", "AFR") ,"Imp.all.equal"] <- TRUE

# Filter the other genotypes
genotypes[!(is.na(genotypes$Genotype_con)) &  (genotypes$Genotype_con == genotypes$Genotype_100 & genotypes$Genotype_100 == genotypes$Genotype_250 & genotypes$Genotype_250 == genotypes$Genotype_500), "Imp.all.equal" ] <-TRUE

genotypes[is.na(genotypes$Genotype_con) & (genotypes$Genotype_100 == genotypes$Genotype_250 & genotypes$Genotype_250 == genotypes$Genotype_500), "Imp.all.equal"] <-TRUE


```


```{r, include = FALSE}
# Check for inversions that did'nt work that well.

#  From african and european
test_dataset<-genotypes[genotypes$Population %in% c("AFR", "EUR"),]

# With good quality
test_dataset<-test_dataset[which(test_dataset$Probability_con>0.8 & test_dataset$Probability_500 > 0.8 & test_dataset$Probability_250 > 0.8 & test_dataset$Probability_100 > 0.8),]

# Which of them were consistent?
test_dataset$working<-"FILTERED"
test_dataset[(test_dataset$Genotype_con == test_dataset$Genotype_100 & test_dataset$Genotype_100 == test_dataset$Genotype_250 & test_dataset$Genotype_250 == test_dataset$Genotype_500), "working"]<-"PASS"

invs_tested<-unique(test_dataset[test_dataset$working == "FILTERED", "Inversion"])

# Delete these invs for the inds without POP info
genotypes[is.na(genotypes$Genotype_con) & genotypes$Inversion %in% invs_tested & genotypes$Imp.all.equal == TRUE,  "Imp.all.equal"]<-NA

# Make column with genotypes

genotypes$Imp.genotype<-NA

genotypes[genotypes$Imputability %in% accepted_tags & genotypes$Imp.min.quality >= 0.8 & (genotypes$Imp.all.equal == TRUE | is.na(genotypes$Imp.all.equal)) , "Imp.genotype"]<-genotypes[genotypes$Imputability %in% accepted_tags & genotypes$Imp.min.quality >= 0.8 & (genotypes$Imp.all.equal == TRUE | is.na(genotypes$Imp.all.equal)) , "Genotype_con"]

genotypes[genotypes$Imputability %in% accepted_tags & genotypes$Imp.min.quality >= 0.8 & (genotypes$Imp.all.equal == TRUE | is.na(genotypes$Imp.all.equal))& is.na(genotypes$Imp.genotype) , "Imp.genotype"]<-genotypes[genotypes$Imputability %in% accepted_tags & genotypes$Imp.min.quality >= 0.8 & (genotypes$Imp.all.equal == TRUE | is.na(genotypes$Imp.all.equal)) & is.na(genotypes$Imp.genotype) , "Genotype_500"]

```

As I mentioned before, one of the uses for imputation results that used a general-population reference is to predict inversion orientations when same-population results are not available. This way of genotyping the inversions is assuming that when the three general-population results have probabilities > 0.8 and predict the same genotype, they will be showing the same result a same-population reference would. Thus, if we observe any inversion to not follow this tendency, we should be careful with the prediction. I searched for inversions in AFR and EUR populations where all IMPUTE2 results had >0.8 Probability but where general-population results were different from the same-population result. Those inversions were: `r paste(invs_tested, collapse=", ")`. In consequence, those results that in column "Imp.all.equal" were marked as TRUE (consistent results) **changed to NA in `r nrow(genotypes[genotypes$Imp.all.equal == "ALERT",])` inversion-individual pairs**.

Finally, **Imp.genotype** has the resulting genotype only for those inversions and individuals that are imputable, have imputation minimum probaility >= 0.8 and have TRUE or NA values in the Imp.all.equal column. The table with the new columns is stored in impute.genotypes_filtered.csv

```{r, include=FALSE}
write.csv(genotypes, file = "impute.genotypes_filtered.csv")
```

# Tag SNP genotyping results 

```{r, include = FALSE}

tagtab<-read.table("../../analysis/2021-01-07_tagsnps_all/tagSNPGenotypedInvs_conc.txt", sep ="\t", skip=1, stringsAsFactors = FALSE)

# Cuando el tagsnp check code vaya bien borrar esto
tagtab$V4<-NULL
colnames(tagtab)<-c("Individual", "TagSNP.genotype", "TagSNP.probability","TagSNP.sequenced","TagSNP.existing", "Inversion", "TagSNP.population")

# Borrar aquellos resultados redundantes!
ceulist<-unique(tagtab[which(tagtab$TagSNP.population == "CEU") , "Inversion" ])
eurlist<-unique(tagtab[which(tagtab$TagSNP.population == "EUR") , "Inversion" ])

tagtab<-tagtab[ which((tagtab$TagSNP.population != "CEU") | (tagtab$TagSNP.population == "CEU" & tagtab$Inversion %in%  ceulist[!(ceulist%in%eurlist)] ))  , ]

tagtab[tagtab$TagSNP.population == "CEU", "TagSNP.population"]<- "EUR"

yrilist<-unique(tagtab[which(tagtab$TagSNP.population == "YRI") , "Inversion" ])
afrlist<-unique(tagtab[which(tagtab$TagSNP.population == "AFR") , "Inversion" ])

tagtab<-tagtab[ which((tagtab$TagSNP.population != "YRI") | (tagtab$TagSNP.population == "YRI" & tagtab$Inversion %in%  yrilist[!(yrilist%in%afrlist)] ))  , ]

tagtab[tagtab$TagSNP.population == "YRI", "TagSNP.population"]<- "AFR"

# Fix individual names
  tagtab$Individual<-sub("nc", "NC", tagtab$Individual, ignore.case = FALSE)
  tagtab$Individual<-sub("ab", "", tagtab$Individual, ignore.case = FALSE)

  tagtab<-tagtab[which(
  (tagtab$TagSNP.population != "EAS" )| 
  (tagtab$TagSNP.population == "EAS" & tagtab$Individual %in%  c("NC10","NC8", "NC9") )
  ), ]
  tagtab<-tagtab[which(
  (tagtab$TagSNP.population != "EUR" )| 
  (tagtab$TagSNP.population == "EUR" & tagtab$Individual %in%  c("NC1" , "NC2"  ,"NC3",  "NC11" ,"NC12", "NC13" ,"NC14" ,"NC15" ,"NC16" ,"NC4" , "NC17" ,"NC18") )
  ), ]
    

  
```

We had `r length(unique(tagtab$Inversion))` inversions with known perfect tag SNPs (LD = 1) in suitable populations. I made a sript that summarizes which are the tag SNP genotypes associated to each inversion orientation in the reference panel, and then uses this as a template to infer the inversion orientations in the sample individuals. The resulting table (example in Table  \@ref(tab:tagSNP)) shows, for each inversion and individual:

* **TagSNP.existing:** how many tag SNPs we know 
* **TagSNP.sequenced:** how many tag SNPs were actually sequenced in the individual VCFs
* **TagSNP.genotype:** the predominant predicted orientation
* **TagSNP.probability:** the percentage of sequenced SNPs that agreed with the orientation prediction.

```{r, include =FALSE}


#  STEP 02
tagtab_test_wide<-dcast(tagtab[tagtab$TagSNP.probability >=0.8,], Individual + Inversion ~ TagSNP.population , value.var = "TagSNP.genotype" )
tagtab_filtered<-do.call(rbind, apply(tagtab_test_wide, 1, function(x){
  
   if(!is.na(x["GLB"])){
     tagtab[tagtab$Individual == x["Individual"] & tagtab$Inversion == x["Inversion"] & tagtab$TagSNP.population == "GLB"  , ]
   } else if(!is.na(x["EUR"]) ){
      tagtab[tagtab$Individual == x["Individual"] & tagtab$Inversion == x["Inversion"] & tagtab$TagSNP.population == "EUR"  , ]
   }else if(!is.na(x["AFR"]) ){
      tagtab[tagtab$Individual == x["Individual"] & tagtab$Inversion == x["Inversion"] & tagtab$TagSNP.population == "AFR"  , ]
   }else if(!is.na(x["EAS"]) ){
      tagtab[tagtab$Individual == x["Individual"] & tagtab$Inversion == x["Inversion"] & tagtab$TagSNP.population == "EAS"  , ]
   }
    }) )

# STEP 3 make summary
tagtab_wide<-dcast(tagtab, Individual + Inversion ~ TagSNP.population , value.var = "TagSNP.genotype" )
tagtab_unfiltered<-do.call(rbind, apply(tagtab_wide, 1, function(x){
  
   if(!is.na(x["GLB"])){
     tagtab[tagtab$Individual == x["Individual"] & tagtab$Inversion == x["Inversion"] & tagtab$TagSNP.population == "GLB"  , ]
   } else if(!is.na(x["EUR"]) ){
      tagtab[tagtab$Individual == x["Individual"] & tagtab$Inversion == x["Inversion"] & tagtab$TagSNP.population == "EUR"  , ]
   }else if(!is.na(x["AFR"]) ){
      tagtab[tagtab$Individual == x["Individual"] & tagtab$Inversion == x["Inversion"] & tagtab$TagSNP.population == "AFR"  , ]
   }else if(!is.na(x["EAS"]) ){
      tagtab[tagtab$Individual == x["Individual"] & tagtab$Inversion == x["Inversion"] & tagtab$TagSNP.population == "EAS"  , ]
   }
    }) )

tagtab_summary<-merge(tagtab_filtered, tagtab_unfiltered[, c("Inversion", "Individual")], all=T)

tagtab_summary[is.na(tagtab_summary$TagSNP.genotype ),  ]<-tagtab_unfiltered[
  tagtab_unfiltered$Individual == tagtab_summary[is.na(tagtab_summary$TagSNP.genotype ),"Individual" ] &
  tagtab_unfiltered$Inversion == tagtab_summary[is.na(tagtab_summary$TagSNP.genotype ),"Inversion" ] , colnames(tagtab_summary)]



```


Due to the looping strategy used by the program, some inversion-individual pairs can be repeated because they were compared against more than one population (e.g. GLB and EUR). Taking into account only results with TagSNP.probability >= 0.8, for each inversion and individual the predicted orientation was selected in order of priority: GLB prediction and then population-specific prediction if GLB not available. **`r nrow(tagtab_summary[tagtab_summary$TagSNP.probability >=0.8,])` out of `r nrow(tagtab_summary)` inversion-individual pairs had at least one valid result available**. 


```{r tagSNP, echo = FALSE}
  # Show
    kbl(
      head(tagtab[,c("Inversion", "Individual", "TagSNP.existing", "TagSNP.sequenced", "TagSNP.genotype", "TagSNP.probability")], 4), booktabs=T, row.names = FALSE, caption = "Sample rows from the tagSNP check results", position = "h")%>%
        kable_styling(position = "center")
```

 The table with each inversion-individual pair and population is stored in tag.genotypes_filtered_detail.csv. The global result for each inversion and individual is in tag.genotypes_filtered.csv.

```{r, include=FALSE}
write.csv(tagtab_summary, file = "tag.genotypes_filtered.csv")
write.csv(tagtab, file = "tag.genotypes_filtered_detail.csv")

```

# Coverage check

For each region, I counted how many SNPs with a global MAF>=0.025 are there in the 1KGP VCFs and how many of them were sequenced in the sample individuals. The ratio between 1KGP SNPs (expected) and sequenced SNPs was used to detect regions and/or individuals with too low coverages, that we expect to give less reliable imputation results.

Most individuals and inversions have an acceptable proportion of the expected SNPs within the imputation region (between 60% and 80%) and 95% of inversion-individual pairs have values above 30% (Figure \@ref(fig:general)). Some inversions have mean relative coverages below 30% (Figure \@ref(fig:mean), and I confirmed that it is a general tendency of those regions, and not a specific individual having a generalized low relative coverage (Figure \@ref(fig:boxplots)). Despite having significantly low relative coverages, some of these inversions have >500 SNPs sequenced, which could be enough to impute the inversion orientation. 

```{r, include = FALSE}

covTab<-read.table("../../analysis/2021-01-11_09_coverage_allinds/coverage_table.txt", header = TRUE)

covTab$seq.vs.exp_total <- covTab$sequenced_1kgp/covTab$total_1kgp
covTab$seq.vs.exp_maf <- covTab$sequenced_maf/covTab$total_maf


# 1. Values can be a little different depending on individual, in many cases there are no SNPs just inside the inversion. 

# ggplot(covTab)+geom_point(aes(x = INV, y = sequenced_total ))+facet_grid(MAF  ~ CI )
# ggplot(covTab)+geom_point(aes(x = INV, y = seq.vs.exp_maf ))+facet_grid(MAF  ~ CI )

```

```{r general, echo = FALSE, message = FALSE, fig.cap="Histogram showing the distribution of realtive coverages in the whole dataset. The red line corresponds to the 95% quantile limit. Most inversion-individual pairs have sequenced vs. expected SNPs with MAF >=0.025 ratios between 0.6 and 0.8.", fig.height=3.5}
# 2. So, without doing inversion means (I just want to know in general how it went and when to discard information). 

quantab <- data.frame(MAF=c(0.025, 0.05))
quantab$down_limit <- c(  quantile(covTab[covTab$CI == 500000 & covTab$MAF == 0.025,"seq.vs.exp_maf"], c(0.05)) , 
                          quantile(covTab[covTab$CI == 500000 & covTab$MAF == 0.05,"seq.vs.exp_maf"], c(0.05)))


ggplot(covTab[covTab$CI == 500000 & covTab$MAF == 0.025,])+geom_histogram(aes(x = seq.vs.exp_maf ))+
  geom_vline(data=quantab[1,], aes(xintercept = down_limit), color = "red", alpha = 0.3)+
  geom_text(data=quantab[1,], aes(x = down_limit, y = 400, label = round(down_limit,4)), color = "red", alpha = 0.5, nudge_x = 0.05)+
  ggtitle("Global distribution of sequenced vs. expected SNPs with MAF>=0.025 proportions ")+
  labs(y = "Amount of inversion-indiivdual pairs", x = "Sequenced / expected SNPs with MAF>=0.025")

```

 
```{r mean, echo  = FALSE, message = FALSE, fig.cap="Each point is the mean sequenced / expected value for SNPs with MAF>=0.025 in a specific inversion region. Labels are shown for inversions with low relative coverages. Only those below the red line are significant.  ",fig.height=3.5}

# 3. Doing inversion means allows us to identify inversions that fail more often
covTab_means<- aggregate( seq.vs.exp_maf ~ INV + MAF + CI  , data = covTab, mean)

cut <- quantile(covTab_means[covTab_means$CI == 500000 & covTab_means$MAF == 0.025,"seq.vs.exp_maf"], c(0.05))
# library(plotly)

# p<-
  ggplot(covTab_means[covTab_means$CI == 500000 & covTab_means$MAF == 0.025,])+ geom_point(aes(x = INV , y = seq.vs.exp_maf))+
  geom_hline(aes(yintercept = cut), color = "red", alpha = 0.3)+
    ggtitle("Mean relative coverage for each inversion")+
  labs(y = "Mean sequenced / expected  \n SNPs with MAF>=0.025", x = "Inversion")+
     theme(axis.text.x=element_blank(),
        axis.ticks.x=element_blank())+
    geom_text(data = covTab_means[covTab_means$CI == 500000 & covTab_means$MAF == 0.025 & covTab_means$seq.vs.exp_maf < 0.55,], aes(x = INV , y = seq.vs.exp_maf, label=INV), nudge_x = 7)+
    geom_text(aes(x = 1 , y = cut, label = round(cut, 4)) , color = "red", alpha = 0.5, nudge_x = 5, nudge_y = 0.02)
    
    

# fig <- ggplotly(p)
# 
# fig

```


```{r boxplots, echo = FALSE, message = FALSE, fig.cap ="Box plots show the distribution of sequneced vs. expected ratio of SNPs with MAF>=0.025 in the 20 individuals for a given inversion. Only inversions with significantly low mean relative coverage are included. The significantly low relative coverage is not caused by a specific individual, it is rather a generalized tendency of each region.",fig.height=3.5}
# 4. Maybe is just one individual introducing bias?

plotable<-covTab[covTab$CI == 500000 & covTab$MAF == 0.025 & covTab$INV %in% c("HsInv0058", "HsInv0239", "HsInv0573", "HsInv1111", "HsInv0382"),]


# sequenced_maf

# p<-
  ggplot(plotable)+ geom_boxplot(aes(x = INV , y = sequenced_maf))+
    ggtitle("Number of sequenced commmon SNPs distribution in inversions with \nsignificantly low relative coverage")+
  labs(y = "Amount of SNPs with MAF>=0.025", x = "Inversion")
# 
# fig <- ggplotly(p)
# 
# fig

```




# Putting it all together

In this last part I create a table where we can see what happened with each inversion in each individual at a glance. Before explaining how inversions were classified, I need to define or revisit some key concepts:

* **Good imputation results:** those cases where Imp.min.quality >= 0.8 and Imp.all.equal is TRUE, that are imputable (i.e. "Tagged", "Imputable" or "No_Polymorphic") in this individual according to their population. 
* **Good tagSNP results:** those cases where a tag SNP check result with TagSNP.probability >= 0.8 was found using either in GLB or same-population reference panels. 
* **Enough coverage:** sequenced vs. existing SNPs with MAF >=0.025 proportion (Cov.seq.vs.exp_maf) is >=0.3 or more than 500 SNPs sequenced (Cov.sequenced_maf).

Knowing these conditions, we can find each inversion-individual pair classified as one of these categories: 

* **Accepted (A)**
    + **A.Tagged**: Good tag SNP results with bad imputation results. Enough coverage. 
    + **A.Imputed**:Good imputation results with bad or no tag SNP results. Enough coverage. 
    + **A.Tag.Imput**: Good imputation and tagSNP results that match with imputation predictions. Enough coverage
* **To check (C)**
    + **C.Tag.Imput**: Good imputation and tag SNP results, not matching. Enough coverage.
    + **C.check.Imput**: Imputation results with NA in the Imp.all.equal column. 
* **Rejected (R)**
    + **R.badImputability**: Not imputable. 
    + **R.badCoverage**: Bad coverage.
    + **R.badImputation**: Bad imputation results without tagSNP information. 
  
In some cases, a record could fit in more than one category (e.g. Not imputable and Bad Coverage), but I tried to apply them in an order that allows us to know the root reason for rejecting genotype prediction (in the example, Not imputable, because we wouldn't be able to predict the orientation even with a Good Coverage).

```{r, include = FALSE}

  allgeno<-merge(genotypes[,c("Inversion", "Individual", "Population", "Imputability", "Imp.min.quality", "Imp.all.equal", "Imp.genotype")], tagtab_summary[,c("Inversion", "Individual", "TagSNP.sequenced","TagSNP.probability", "TagSNP.population",  "TagSNP.genotype")], by = c("Inversion", "Individual"), all = TRUE)

    # Get individual names for coverage table
    covTab$IND<-sub("^\\d+\\.","",covTab$IND)
    covTab$IND<-sub("nc", "NC", covTab$IND, ignore.case = FALSE)
    covTab$IND<-sub("ab", "", covTab$IND, ignore.case = FALSE)

  allgeno<-merge(allgeno, covTab[covTab$MAF == 0.025 & covTab$CI == 500000,c("IND", "INV", "seq.vs.exp_maf", "sequenced_maf")] , by.x = c("Inversion", "Individual") , by.y = c("INV", "IND"), all.x=TRUE)


# Set filters
  
  # Good imputation = !(is.na(allgeno$Imp.genotype))
  # Good tagSNP =  allgeno$TagSNP.probability >=0.8 
  # Bad coverage =  allgeno$seq.vs.exp_maf < 0.3 & allgeno$sequenced_maf < 500 
  # Not good tag SNP = (allgeno$TagSNP.probability < 0.8 | is.na(allgeno$TagSNP.probability ))

  # R.badImputability
  allgeno$Result<-NA
  allgeno[!(allgeno$Imputability %in% accepted_tags) & # Imputation is not Tagged, not polymorphic or imputable
            is.na(allgeno$Result) , "Result"]<-"R.badImputability"
  
  # R.badCoverage
  allgeno[which( allgeno$seq.vs.exp_maf < 0.3 & allgeno$sequenced_maf < 500 &  # Has bad coverage
                  is.na(allgeno$Result)) , "Result"]<-"R.badCoverage"
  
  # R.badImputation
  allgeno[which( is.na(allgeno$Imp.genotype) & # Not good imputatoin
                  (allgeno$TagSNP.probability < 0.8 | is.na(allgeno$TagSNP.probability )) &  # Not good tag SNP
                   is.na(allgeno$Result)), "Result"]<-"R.badImputation"
  
  # C.Tag.Imput
  allgeno[which( !(is.na(allgeno$Imp.genotype))& # Good imputation
                   allgeno$TagSNP.probability >=0.8 & # Good tag SNP
                   allgeno$Imp.genotype != allgeno$TagSNP.genotype & # Imputation not equal to tag snp
                   is.na(allgeno$Result)), "Result"]<-"C.Tag.Imput"
    
  # C.check.Imput
  allgeno[which( allgeno$Imp.min.quality >= 0.8 & # Should be a good imputation
                  is.na(allgeno$Imp.all.equal) & # Marked as NA in all equal because assumptions are not always met
                  is.na(allgeno$Result)), "Result"]<-"C.check.Imput"
  
  # A.Tagged
  allgeno[which( allgeno$TagSNP.probability >=0.8 & # Good tagSNP
                   is.na(allgeno$Imp.genotype) & #Not good imputation
                   is.na(allgeno$Result)), "Result"]<-"A.Tagged"
  
  # A.Imputed
  allgeno[which(!(is.na(allgeno$Imp.genotype))& # Good imputation
                (allgeno$TagSNP.probability < 0.8 | is.na(allgeno$TagSNP.probability )) & # Not good tag SNP
                  is.na(allgeno$Result)), "Result"]<-"A.Imputed"
  
  # A.Tag.Imput
  allgeno[which( !(is.na(allgeno$Imp.genotype)) & # Good imputation
                  allgeno$TagSNP.probability >=0.8 & # Good tagSNP
                  allgeno$Imp.genotype == allgeno$TagSNP.genotype & # Imputation equal to tag snp
                  is.na(allgeno$Result)), "Result"]<-"A.Tag.Imput"
  
  
  colnames(allgeno)[ colnames(allgeno) %in% c("seq.vs.exp_maf"  ,   "sequenced_maf" ) ]<-c("Cov.seq.vs.exp_maf", "Cov.sequenced_maf")
  


  
  
```

Once the genotypes are filtered depending on the imputation, tagSNP and coverage results, they are aggregated and counted to filter inversions by the amount of different quality haplotypes available, introducing a new Rejected (R) category: **R.lowSample**, which will be assigned to previously Accepted (A) results whose inversions don't have more than 3 individuals genotyped and both heterozygous and homozygous individuals available. The final table (example in Table \@ref(tab:final)) is stored in allgenotypes_classified.csv.

```{r, include = FALSE}
# GLOBAL03

   geno_filtered<-allgeno[allgeno$Result %in% c("A.Tagged" ,"A.Tag.Imput","A.Imputed"  ) ,]

    geno_filtered$Genotype<-ifelse(is.na(geno_filtered$Imp.genotype), geno_filtered$TagSNP.genotype, geno_filtered$Imp.genotype)
    
    counts<-data.frame(unclass(table(as.character(geno_filtered$Inversion), geno_filtered$Genotype)))
    
    counts$HOMO <- counts$INV + counts$STD
    counts$all<-counts$HET + counts$HOMO

    colnames(counts)<- paste0(colnames(counts),".genotype")
    counts$Inversion<-rownames(counts)

    allgeno<-merge(allgeno, counts[,c("HET.genotype", "HOMO.genotype", "all.genotype", "Inversion")],all=TRUE, by = "Inversion")
    
    allgeno[which( allgeno$Result %in% c("A.Tagged" ,"A.Tag.Imput","A.Imputed") & # Previously accepted results
      !(allgeno$all.genotype > 3 &  (allgeno$HET.genotype > 0 & allgeno$HOMO.genotype > 0)) # Not enough sample
                   ), "Result"]<-"R.lowSample"

  
    
```


```{r final, echo = FALSE}
allgeno<-allgeno[,c("Inversion","Individual","Population","Result","Imputability","Imp.min.quality","Imp.all.equal","Imp.genotype",       "TagSNP.sequenced","TagSNP.probability", "TagSNP.population" , "TagSNP.genotype" ,   "Cov.seq.vs.exp_maf","Cov.sequenced_maf" ,"HET.genotype","HOMO.genotype","all.genotype"   )]

  # Show

       kbl(
      head(allgeno[,c(1:9)]), booktabs=T, row.names = FALSE,  caption = "Sample summary table for the results", position = "h")%>%
        kable_styling(position = "center", latex_options =c( "scale_down"))
kbl(
      head(allgeno[,c(10:17)]), booktabs=T, row.names = FALSE, position = "h")%>%
        kable_styling(position = "center", latex_options =c( "scale_down"))

```


In addition, a per-inversion summary table with the amount of correctly genotyped individuals and a column indicating whether the inversion was "Accepted", "lowSample" or "unableToGenotype" is stored in inversions_summary.csv,


```{r, include=FALSE}
write.csv(allgeno, file = "allgenotypes_classified.csv")

invSummary<-unique(allgeno[, c("Inversion", "HET.genotype", "HOMO.genotype", "all.genotype")])
invSummary$Result<-"lowSample"
invSummary[which(invSummary$all.genotype > 3 &  (invSummary$HET.genotype > 0 & invSummary$HOMO.genotype > 0)), "Result"]<-"Accepted"
invSummary[which( is.na(invSummary$all.genotype ) ), "Result"]<-"unableToGenotype"

invSummary[is.na(invSummary)] <- 0

write.csv(invSummary, file = "inversions_summary.csv")

```

Figure  \@ref(fig:results) shows the incidence of each classification category. **`r nrow(allgeno[allgeno$Result %in% c(c("A.Tagged" ,"A.Tag.Imput","A.Imputed"  )) ,])` inversion-individual pairs from `r sum(invSummary$Result == "Accepted")` inversions were finally accepted for analysis**. `r sum(invSummary$Result == "lowSample")` inversions were genotyped but not in enough heterozygous or total individuals to be analyzed, and `r sum(invSummary$Result == "unableToGenotype")` couldn't be genotyped at all.

```{r results, echo = FALSE, fig.cap ="Final status of each inversion-individual pair. In most cases the imputation worked well, and almost half of the imputation results are supported by a tag SNP check. 5 pairs were recovered thanks to the tag SNP check and 18 cases have to yet be revised and are potentially useful. The main reasons for sample loss are the inversion not being imputable in the individual's population and inversions not having enough samples to compare heterozygous vs homozygous tendencies. "}

results_summary<-data.frame(table(allgeno$Result))


ggplot(results_summary,aes(x=Var1, y =Freq))+geom_bar(stat="Identity")+geom_text(aes(label=Freq), vjust = -0.25)+
  ggtitle("Incidence of each classification category")+
  labs(y = "Amount of inversion-individual pairs", x = "Category")+
   theme(axis.text.x = element_text(angle = 45, hjust = 1))
  

```



