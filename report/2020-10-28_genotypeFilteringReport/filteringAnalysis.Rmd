---
title: "Genotype inference analysis"
author: "Ruth Gómez Graciani"
output:
  bookdown::pdf_document2:
    toc: false
    latex_engine: xelatex
  header-includes:
  - \usepackage{xcolor}
  - \usepackage{framed}


mainfont: OpenSans
---

\colorlet{shadecolor}{teal!10} 

_In this report, I put together IMPUTE2 results, genotypes inferred from tag SNPs and a coverage analysis to elaborte a definitive dataset of inversions reliably genotyped in as much individuals as possible from the 20 originally available. Those inversions genotyped in more than 3 individuals with at least 1 heterozygous and 1 homozygous sample will be used in later analyses. _

```{r setup, include=FALSE}
require("stringr")
require("reshape2")
library("ggplot2")
library("kableExtra")
library("ggforce")

```

# IMPUTE2 results

\begin{shaded}

\textbf{Note about individuals' populations:} As explained in previous reports and in the wiki, we had 20 individuals from different populations. Some individuals had confusing or unespecific ancestry information, so I did a PCA to confirm their origin. The final distribution was 12 EUR, 3 AFR, 3 EAS, 1 SAS, 1 Admixed. 
\end{shaded}

IMPUTE2 infers unknown genotypes for variants in a sample using a set of reference haplotypes from genotyped individuals. As a general rule, the more reference individuals, the better is the imputation precision. On the other hand, we must be careful when imputing recurrent inversions: haplotypes from opposite orientations could be more similar than normal and differences in recurrence rates between populations can be misleading for the program. 

```{r loadData, include=FALSE}

# LOAD DATA
  # Imputability
  input.invs<-read.table("../../data/use/inversions_info/Inversions_imputability.txt", header = TRUE, stringsAsFactors = F)
  
  # Coordinates
  coord.invs<-read.table("../../data/use/inversions_info/Inversions_coordinates_hg19.csv", col.names = c("Inversion", "chromosome", "B1s19", "B1e19", "B2s19", "B2e19"), stringsAsFactors = F)

  # Recurrence
  rec.invs<-read.table("../../data/use/inversions_info/2021-02_recurrenceInfo.csv", header = T, stringsAsFactors = F, sep = "\t")
  rec.invs[rec.invs=="Unique?"]<-"Recurrent"
  rec.invs[rec.invs=="ND"]<-NA

  # New names
  namechanges<-read.table("../../data/use/inversions_info/2021.01.19to38nameChanges", header = TRUE, stringsAsFactors = FALSE)
  rownames(namechanges)<-namechanges$hg38
  namechanges<-namechanges[namechanges$hg38 != "HsInv1075",]
  rec.invs[rec.invs$Inversion %in% namechanges$hg38, "Inversion"]<-namechanges[rec.invs[rec.invs$Inversion %in% namechanges$hg38, "Inversion"],"hg19"]

# MERGE DATA
  invs<- merge(coord.invs[, c("Inversion", "chromosome")], input.invs , all = TRUE, by = "Inversion")
  invs<-merge(invs, rec.invs[,c("Inversion", "Origin")], all.x = T, by = "Inversion")

# CHANGE ORIGIN IN DEL INVS
  # invs[grep( ".*id$", invs$Inversion),]
  for (inv in c("HsInv0052", "HsInv0370", "HsInv1075")){
    invs[grep( inv, invs$Inversion),c( "Origin")]<-rec.invs[rec.invs$Inversion == inv, c( "Origin")]
  }

# FILTER AUTOSOMAL IMPUTABLE
  # Autosomal
  invs<-invs[!(invs$chromosome %in% c("chrX", "chrY"))&!is.na(invs$chromosome),] #HsInv0822 is chrX and NA
  # Imputable
  accepted_tags<-c("Tagged", "Imputable", "No_Polymorphic")
  goodinvs_count <- invs[(invs$GLB %in% accepted_tags | invs$EUR %in% accepted_tags | invs$AFR %in% accepted_tags) ,]

# GREP invs with 3 options due to DEL genotype
  amount_delinvs.input<-nrow(input.invs[grep( ".*id$", input.invs$Inversion),])
  amount_delinvs.invs<-nrow(goodinvs_count[grep( ".*id$", goodinvs_count$Inversion),])
```

We have a list of `r nrow(input.invs) - (amount_delinvs.input*2)` inversions that were classified according to their imputability (i.e. IMPUTE2 success rate in inferring the same inversion orientations as in experimental genotype validations in a set of individuals). The imputability information was available for AFR and EUR populations and we had a global (GLB) estimation as well. We selected for the analysis only those that were autosomal and imputable in at least one population (`r nrow(goodinvs_count) - (amount_delinvs.invs*2)` inversions). 

We imputed each inversion in those individuals classified as "Tagged", "Imputable" or "No_Polymorphic" in their respective population  (EAS, SAS and the admixed individual were assessed according to the GLB column). The reference sample size was a maximum of 500 haplotypes. When we had more than 500 reference haplotypes available, IMPUTE2 automatically selected them sorted by similarity to the individual to genotype. The origin of references varied depending on the inversions' recurrence: from the global dataset for unique inversions and from a same-population dataset for recurrent inversions. 

```{r impute2, echo =FALSE}

 # LOAD IMPUTE2 RESULTS
   # Get individuals genotypes
    genotypes<-read.table("../../analysis/2021-01-11_07_imputationTables/imputationResults.csv", header=TRUE, sep = ",", stringsAsFactors = FALSE)
  
    # Get individual names
    genotypes$Individual<-sub("^\\d+\\.","",genotypes$Individual)
    genotypes$Individual<-sub("nc", "NC", genotypes$Individual, ignore.case = FALSE)
    genotypes$Individual<-sub("ab", "", genotypes$Individual, ignore.case = FALSE)

    genotypes$GLB<-genotypes$AFR<-genotypes$EUR <- NULL

    # Merge in important info
    genotypes<-merge(genotypes, invs, all.x = TRUE)
    
# STEP01: imputability 
  genotypes$Imputability<-ifelse(genotypes$Population %in% c("SAS", "ALL", "EAS"), genotypes$GLB,
                          ifelse(genotypes$Population =="AFR", genotypes$AFR, genotypes$EUR))

# STEP02: reference sample according to recurrence

  genotypes$Probability<-ifelse( (is.na(genotypes$Origin)|genotypes$Origin == "Recurrent"), 
                                  genotypes$Probability_con, genotypes$Probability_500)
  genotypes$Genotype<-ifelse( (is.na(genotypes$Origin)|genotypes$Origin == "Recurrent"), 
                                  genotypes$Genotype_con, genotypes$Genotype_500)
  
# MAKE FINAL (clean) TABLE

    genotypes<-genotypes[,c("Inversion", "Individual", "Population", "Imputability", "Origin", "Probability", "Genotype")]
```

The result table (example in Table  \@ref(tab:imputability), shows for each inversion and individual (inversion-individual pair), the Genotype predicted by IMPUTE2 and a Probability score indicating how reliable is the result. `r sum(is.na(genotypes[genotypes$Imputability %in% accepted_tags,  "Probability"]))` inversion-individual pairs, mostly from SAS and Admixed individuals, did not have enough reference samples to be imputed. 

```{r imputability, echo = FALSE}
  # Show
    kbl(
      head(genotypes, 4), booktabs=T, row.names = FALSE, caption = "Sample rows from the imputation results", position = "h")%>%
        kable_styling(position = "center")

```

We established a minimum threshold of 90% Probability for a result to be accepted, which is the highest we can go without losing too much information (Figure \@ref(fig:thresholdplot)). 

```{r thresholdplot, echo = FALSE, message = FALSE, fig.cap ="This plot shows how many inversion-individual pairs will be filtered depending on the threshold applied to imputation results. From the 6 thresholds here proposed, 0.9 is the highest one that leaves out less than 10% of the data",fig.height=3.5}

toplot<-genotypes[genotypes$Imputability %in% accepted_tags, ]

takeloss<-function(x){nrow(toplot[toplot$Probability <x,])}
takeperc<-function(x){nrow(toplot[toplot$Probability <x,])/nrow(toplot)*100}

losses<-data.frame(threshold=seq(0.75,1, 0.05))
losses$loss<-apply(losses, 1, function(x) {takeloss(x["threshold"])})
losses$percentage<-round(apply(losses, 1, function(x) {takeperc(x["threshold"])}),2)

ggplot(losses, aes(x = as.factor(threshold), y = loss))+geom_bar(stat = "identity")+
  geom_text(aes(label=paste0(loss," (", percentage, ")")), nudge_y =  30)+
  ggtitle("Quantitiy of filtered information depending on imputation threshold")+
  labs(y = "Filtered inversion-individual pairs", x = "Imputation threshold")

```

# Tag SNP genotyping results 

```{r, include = FALSE}

tagtab<-read.table("../../analysis/2021-01-07_tagsnps_all/tagSNPGenotypedInvs_conc.txt", sep ="\t", skip=1, stringsAsFactors = FALSE)

# Cuando el tagsnp check code vaya bien borrar esto
tagtab$V4<-NULL
colnames(tagtab)<-c("Individual", "TagSNP.genotype", "TagSNP.probability","TagSNP.sequenced","TagSNP.existing", "Inversion", "TagSNP.population")

# Borrar aquellos resultados redundantes!
ceulist<-unique(tagtab[which(tagtab$TagSNP.population == "CEU") , "Inversion" ])
eurlist<-unique(tagtab[which(tagtab$TagSNP.population == "EUR") , "Inversion" ])

tagtab<-tagtab[ which((tagtab$TagSNP.population != "CEU") | (tagtab$TagSNP.population == "CEU" & tagtab$Inversion %in%  ceulist[!(ceulist%in%eurlist)] ))  , ]

tagtab[tagtab$TagSNP.population == "CEU", "TagSNP.population"]<- "EUR"

yrilist<-unique(tagtab[which(tagtab$TagSNP.population == "YRI") , "Inversion" ])
afrlist<-unique(tagtab[which(tagtab$TagSNP.population == "AFR") , "Inversion" ])

tagtab<-tagtab[ which((tagtab$TagSNP.population != "YRI") | (tagtab$TagSNP.population == "YRI" & tagtab$Inversion %in%  yrilist[!(yrilist%in%afrlist)] ))  , ]

tagtab[tagtab$TagSNP.population == "YRI", "TagSNP.population"]<- "AFR"

# Fix individual names
  tagtab$Individual<-sub("nc", "NC", tagtab$Individual, ignore.case = FALSE)
  tagtab$Individual<-sub("ab", "", tagtab$Individual, ignore.case = FALSE)

  tagtab<-tagtab[which(
  (tagtab$TagSNP.population != "EAS" )| 
  (tagtab$TagSNP.population == "EAS" & tagtab$Individual %in%  c("NC10","NC8", "NC9") )
  ), ]
  tagtab<-tagtab[which(
  (tagtab$TagSNP.population != "EUR" )| 
  (tagtab$TagSNP.population == "EUR" & tagtab$Individual %in%  c("NC1" , "NC2"  ,"NC3",  "NC11" ,"NC12", "NC13" ,"NC14" ,"NC15" ,"NC16" ,"NC4" , "NC17" ,"NC18") )
  ), ]
    

  
```

We had `r length(unique(tagtab$Inversion))` inversions with known perfect tag SNPs (LD = 1) in suitable populations. I made a script that summarizes which are the tag SNP genotypes associated to each inversion orientation in the reference panel, and then uses this as a template to infer the inversion orientations in the sample individuals. The resulting table (example in Table  \@ref(tab:tagSNP)) shows, for each inversion and individual:

* **TagSNP.existing:** how many tag SNPs we know 
* **TagSNP.sequenced:** how many tag SNPs were actually sequenced in the individual VCFs
* **TagSNP.genotype:** the predominant predicted orientation
* **TagSNP.probability:** the percentage of sequenced SNPs that agreed with the orientation prediction.

```{r, include =FALSE}


#  STEP 02
tagtab_test_wide<-dcast(tagtab[tagtab$TagSNP.probability >=0.8,], Individual + Inversion ~ TagSNP.population , value.var = "TagSNP.genotype" )
tagtab_filtered<-do.call(rbind, apply(tagtab_test_wide, 1, function(x){
  
   if(!is.na(x["GLB"])){
     tagtab[tagtab$Individual == x["Individual"] & tagtab$Inversion == x["Inversion"] & tagtab$TagSNP.population == "GLB"  , ]
   } else if(!is.na(x["EUR"]) ){
      tagtab[tagtab$Individual == x["Individual"] & tagtab$Inversion == x["Inversion"] & tagtab$TagSNP.population == "EUR"  , ]
   }else if(!is.na(x["AFR"]) ){
      tagtab[tagtab$Individual == x["Individual"] & tagtab$Inversion == x["Inversion"] & tagtab$TagSNP.population == "AFR"  , ]
   }else if(!is.na(x["EAS"]) ){
      tagtab[tagtab$Individual == x["Individual"] & tagtab$Inversion == x["Inversion"] & tagtab$TagSNP.population == "EAS"  , ]
   }
    }) )

# STEP 3 make summary
tagtab_wide<-dcast(tagtab, Individual + Inversion ~ TagSNP.population , value.var = "TagSNP.genotype" )
tagtab_unfiltered<-do.call(rbind, apply(tagtab_wide, 1, function(x){
  
   if(!is.na(x["GLB"])){
     tagtab[tagtab$Individual == x["Individual"] & tagtab$Inversion == x["Inversion"] & tagtab$TagSNP.population == "GLB"  , ]
   } else if(!is.na(x["EUR"]) ){
      tagtab[tagtab$Individual == x["Individual"] & tagtab$Inversion == x["Inversion"] & tagtab$TagSNP.population == "EUR"  , ]
   }else if(!is.na(x["AFR"]) ){
      tagtab[tagtab$Individual == x["Individual"] & tagtab$Inversion == x["Inversion"] & tagtab$TagSNP.population == "AFR"  , ]
   }else if(!is.na(x["EAS"]) ){
      tagtab[tagtab$Individual == x["Individual"] & tagtab$Inversion == x["Inversion"] & tagtab$TagSNP.population == "EAS"  , ]
   }
    }) )

tagtab_summary<-merge(tagtab_filtered, tagtab_unfiltered[, c("Inversion", "Individual")], all=T)

tagtab_summary[is.na(tagtab_summary$TagSNP.genotype ),  ]<-tagtab_unfiltered[
  tagtab_unfiltered$Individual == tagtab_summary[is.na(tagtab_summary$TagSNP.genotype ),"Individual" ] &
  tagtab_unfiltered$Inversion == tagtab_summary[is.na(tagtab_summary$TagSNP.genotype ),"Inversion" ] , colnames(tagtab_summary)]



```

Due to the looping strategy used by the program, some inversion-individual pairs can be repeated because they were compared against more than one population (e.g. GLB and EUR). Taking into account only results with TagSNP.probability >= 0.8, for each pair the predicted orientation was selected in order of priority: GLB prediction and then population-specific prediction if GLB not available. **`r nrow(tagtab_summary[tagtab_summary$TagSNP.probability >=0.8,])` out of `r nrow(tagtab_summary)` inversion-individual pairs had at least one valid result available**. 

```{r tagSNP, echo = FALSE}
  # Show
    kbl(
      head(tagtab[,c("Inversion", "Individual", "TagSNP.existing", "TagSNP.sequenced", "TagSNP.genotype", "TagSNP.probability")], 4), booktabs=T, row.names = FALSE, caption = "Sample rows from the tagSNP check results", position = "h")%>%
        kable_styling(position = "center")
```

 The table with each inversion-individual pair and population is stored in tag.genotypes_filtered_detail.csv. The global result for each inversion and individual is in tag.genotypes_filtered.csv.

```{r, include=FALSE}
write.csv(tagtab_summary, file = "tag.genotypes_filtered.csv")
write.csv(tagtab, file = "tag.genotypes_filtered_detail.csv")

```

# Coverage check

For each region, I counted how many SNPs with a global MAF>=0.025 are there in the 1KGP VCFs and how many of them were sequenced in the sample individuals. The ratio between 1KGP SNPs (expected) and sequenced SNPs was used to detect regions and/or individuals with too low coverages, that we expect to give less reliable imputation results.

Most individuals and inversions have an acceptable proportion of the expected SNPs within the imputation region (between 60% and 80%) and 95% of inversion-individual pairs have values above 30% (Figure \@ref(fig:general)). Some inversions have mean relative coverages below 30% (Figure \@ref(fig:mean), and I confirmed that it is a general tendency of those regions, and not a specific individual having a generalized low relative coverage (Figure \@ref(fig:boxplots)). Despite having significantly low relative coverages, some of these inversions have >500 SNPs sequenced, which could be enough to impute the inversion orientation. 

```{r, include = FALSE}

covTab<-read.table("../../analysis/2021-01-11_09_coverage_allinds/coverage_table.txt", header = TRUE)

covTab$seq.vs.exp_total <- covTab$sequenced_1kgp/covTab$total_1kgp
covTab$seq.vs.exp_maf <- covTab$sequenced_maf/covTab$total_maf


# 1. Values can be a little different depending on individual, in many cases there are no SNPs just inside the inversion. 

# ggplot(covTab)+geom_point(aes(x = INV, y = sequenced_total ))+facet_grid(MAF  ~ CI )
# ggplot(covTab)+geom_point(aes(x = INV, y = seq.vs.exp_maf ))+facet_grid(MAF  ~ CI )

```

```{r general, echo = FALSE, message = FALSE, fig.cap="Histogram showing the distribution of realtive coverages in the whole dataset. The red line corresponds to the 95% quantile limit. Most inversion-individual pairs have sequenced vs. expected SNPs with MAF >=0.025 ratios between 0.6 and 0.8.", fig.height=3.5}
# 2. So, without doing inversion means (I just want to know in general how it went and when to discard information). 

quantab <- data.frame(MAF=c(0.025, 0.05))
quantab$down_limit <- c(  quantile(covTab[covTab$CI == 500000 & covTab$MAF == 0.025,"seq.vs.exp_maf"], c(0.05)) , 
                          quantile(covTab[covTab$CI == 500000 & covTab$MAF == 0.05,"seq.vs.exp_maf"], c(0.05)))


ggplot(covTab[covTab$CI == 500000 & covTab$MAF == 0.025,])+geom_histogram(aes(x = seq.vs.exp_maf ))+
  geom_vline(data=quantab[1,], aes(xintercept = down_limit), color = "red", alpha = 0.3)+
  geom_text(data=quantab[1,], aes(x = down_limit, y = 400, label = round(down_limit,4)), color = "red", alpha = 0.5, nudge_x = 0.05)+
  ggtitle("Global distribution of sequenced vs. expected SNPs with MAF>=0.025 proportions ")+
  labs(y = "Amount of inversion-indiivdual pairs", x = "Sequenced / expected SNPs with MAF>=0.025")

```

 
```{r mean, echo  = FALSE, message = FALSE, fig.cap="Each point is the mean sequenced / expected value for SNPs with MAF>=0.025 in a specific inversion region. Labels are shown for inversions with low relative coverages. Only those below the red line are significant.  ",fig.height=3.5}

# 3. Doing inversion means allows us to identify inversions that fail more often
covTab_means<- aggregate( seq.vs.exp_maf ~ INV + MAF + CI  , data = covTab, mean)

cut <- quantile(covTab_means[covTab_means$CI == 500000 & covTab_means$MAF == 0.025,"seq.vs.exp_maf"], c(0.05))
# library(plotly)

# p<-
  ggplot(covTab_means[covTab_means$CI == 500000 & covTab_means$MAF == 0.025,])+ geom_point(aes(x = INV , y = seq.vs.exp_maf))+
  geom_hline(aes(yintercept = cut), color = "red", alpha = 0.3)+
    ggtitle("Mean relative coverage for each inversion")+
  labs(y = "Mean sequenced / expected  \n SNPs with MAF>=0.025", x = "Inversion")+
     theme(axis.text.x=element_blank(),
        axis.ticks.x=element_blank())+
    geom_text(data = covTab_means[covTab_means$CI == 500000 & covTab_means$MAF == 0.025 & covTab_means$seq.vs.exp_maf < 0.55,], aes(x = INV , y = seq.vs.exp_maf, label=INV), nudge_x = 7)+
    geom_text(aes(x = 1 , y = cut, label = round(cut, 4)) , color = "red", alpha = 0.5, nudge_x = 5, nudge_y = 0.02)
    
    

# fig <- ggplotly(p)
# 
# fig

```


```{r boxplots, echo = FALSE, message = FALSE, fig.cap ="Box plots show the distribution of sequneced vs. expected ratio of SNPs with MAF>=0.025 in the 20 individuals for a given inversion. Only inversions with significantly low mean relative coverage are included. The significantly low relative coverage is not caused by a specific individual, it is rather a generalized tendency of each region.",fig.height=3.5}
# 4. Maybe is just one individual introducing bias?

plotable<-covTab[covTab$CI == 500000 & covTab$MAF == 0.025 & covTab$INV %in% c("HsInv0058", "HsInv0239", "HsInv0573", "HsInv1111", "HsInv0382"),]


# sequenced_maf

# p<-
  ggplot(plotable)+ geom_boxplot(aes(x = INV , y = sequenced_maf))+
    ggtitle("Number of sequenced commmon SNPs distribution in inversions with \nsignificantly low relative coverage")+
  labs(y = "Amount of SNPs with MAF>=0.025", x = "Inversion")
# 
# fig <- ggplotly(p)
# 
# fig

```


# Putting it all together

In this last part I create a table where we can see what happened with each inversion in each individual at a glance. Before explaining how inversions were classified, I need to define or revisit some key concepts:

* **Good imputation results:** those cases that are imputable (i.e. "Tagged", "Imputable" or "No_Polymorphic") and imputation Probability is >= 0.9.
* **Good tagSNP results:** those cases where a tag SNP check result with TagSNP.probability >= 0.8 was found using either in GLB or same-population reference panels. 
* **Enough coverage:** sequenced vs. existing SNPs with MAF >=0.025 proportion (Cov.seq.vs.exp_maf) is >=0.3 or more than 500 SNPs sequenced (Cov.sequenced_maf).

Knowing these conditions, we can find each inversion-individual pair classified as one of these categories: 

* **Accepted (A)**
    + **A.Tag.Imput**: Good imputation and tagSNP results that match with imputation predictions. Enough coverage
    + **A.Tagged**: Good tag SNP results with bad imputation results. Enough coverage. 
    + **A.Imputed**:Good imputation results with bad or no tag SNP results. Enough coverage. 
* **To check (C)**
    + **C.Tag.Imput**: Good imputation and tag SNP results, not matching. Enough coverage.
* **Rejected (R)**
    + **R.badImputation**: Bad imputation results without tagSNP information. 
    + **R.badCoverage**: Bad coverage.
    + **R.badImputability**: Not imputable. 

  
In some cases, a record could fit in more than one category (e.g. Not imputable and Bad Coverage), but I tried to apply them in an order that allows us to know the root reason for rejecting genotype prediction (in the example, Not imputable, because we wouldn't be able to predict the orientation even with a Good Coverage).

```{r, include = FALSE}

  allgeno<-merge(genotypes, tagtab_summary[,c("Inversion", "Individual", "TagSNP.sequenced","TagSNP.probability", "TagSNP.population",  "TagSNP.genotype")], by = c("Inversion", "Individual"), all = TRUE)
  colnames(allgeno)[colnames(allgeno) %in% c("Probability","Genotype")]<-c("Imp.probability", "Imp.genotype")
  
    # Get individual names for coverage table
    covTab$IND<-sub("^\\d+\\.","",covTab$IND)
    covTab$IND<-sub("nc", "NC", covTab$IND, ignore.case = FALSE)
    covTab$IND<-sub("ab", "", covTab$IND, ignore.case = FALSE)

  allgeno<-merge(allgeno, covTab[covTab$MAF == 0.025 & covTab$CI == 500000,c("IND", "INV", "seq.vs.exp_maf", "sequenced_maf")] , by.x = c("Inversion", "Individual") , by.y = c("INV", "IND"), all.x=TRUE)


# Set filters
  allgeno$Result<-NA
  
  # Good imputation = (!(is.na(allgeno$Imp.probability)) & allgeno$Imp.probability >= 0.9)
  # Good tagSNP =  allgeno$TagSNP.probability >=0.8 
  # Bad coverage =  allgeno$seq.vs.exp_maf < 0.3 & allgeno$sequenced_maf < 500 
  # Not good tag SNP = (allgeno$TagSNP.probability < 0.8 | is.na(allgeno$TagSNP.probability ))
  # Not good imputation = (allgeno$Imp.probability < 0.9 | is.na(allgeno$Imp.probability ))

  
  # R.badImputability
  allgeno[!(allgeno$Imputability %in% accepted_tags) & # Imputation is not Tagged, not polymorphic or imputable
            is.na(allgeno$Result) , "Result"]<-"R.badImputability"
  
  # R.badCoverage
  allgeno[which( allgeno$seq.vs.exp_maf < 0.3 & allgeno$sequenced_maf < 500 &  # Has bad coverage
                  is.na(allgeno$Result)) , "Result"]<-"R.badCoverage"
  
  # R.badImputation
  allgeno[which( (allgeno$Imp.probability < 0.9 | is.na(allgeno$Imp.probability ) )& # Not good imputation
                  (allgeno$TagSNP.probability < 0.8 | is.na(allgeno$TagSNP.probability )) &  # Not good tag SNP
                   is.na(allgeno$Result)), "Result"]<-"R.badImputation"
  
  # C.Tag.Imput
  allgeno[which( (!(is.na(allgeno$Imp.probability)) & allgeno$Imp.probability >= 0.9) & # Good imputation
                   allgeno$TagSNP.probability >=0.8 & # Good tag SNP
                   allgeno$Imp.genotype != allgeno$TagSNP.genotype & # Imputation not equal to tag snp
                   is.na(allgeno$Result)), "Result"]<-"C.Tag.Imput"
    
  # A.Tagged
  allgeno[which( allgeno$TagSNP.probability >=0.8 & # Good tagSNP
                   (allgeno$Imp.probability < 0.9 | is.na(allgeno$Imp.probability )) & #Not good imputation
                   is.na(allgeno$Result)), "Result"]<-"A.Tagged"
  
  # A.Imputed
  allgeno[which( (!(is.na(allgeno$Imp.probability)) & allgeno$Imp.probability >= 0.9)& # Good imputation
                (allgeno$TagSNP.probability < 0.8 | is.na(allgeno$TagSNP.probability )) & # Not good tag SNP
                  is.na(allgeno$Result)), "Result"]<-"A.Imputed"
  
  # A.Tag.Imput
  allgeno[which(  (!(is.na(allgeno$Imp.probability)) & allgeno$Imp.probability >= 0.9) & # Good imputation
                  allgeno$TagSNP.probability >=0.8 & # Good tagSNP
                  allgeno$Imp.genotype == allgeno$TagSNP.genotype & # Imputation equal to tag snp
                  is.na(allgeno$Result)), "Result"]<-"A.Tag.Imput"
  
  
  colnames(allgeno)[ colnames(allgeno) %in% c("seq.vs.exp_maf"  ,   "sequenced_maf" ) ]<-c("Cov.seq.vs.exp_maf", "Cov.sequenced_maf")
  

```

Once the genotypes are filtered depending on the imputation, tagSNP and coverage results, they are aggregated and counted to filter inversions by the amount of different quality haplotypes available, introducing a new Rejected (R) category: **R.lowSample**, which will be assigned to previously Accepted (A) results whose inversions don't have more than 3 individuals genotyped and both heterozygous and homozygous individuals available. The final table (example in Table \@ref(tab:final)) is stored in allgenotypes_classified.csv.

```{r, include = FALSE}

# Make inversion summary before R.lowSample

invSummary<-allgeno[,c( "Inversion", "Result")]
invSummary$counts<-1
invSummary<-aggregate(counts ~ Inversion + Result,  invSummary, sum )
invSummary<-dcast(invSummary, Inversion ~ Result)

# R.lowSample

   geno_filtered<-allgeno[allgeno$Result %in% c("A.Tagged" ,"A.Tag.Imput","A.Imputed"  ) ,]

    geno_filtered$Genotype<-ifelse(is.na(geno_filtered$Imp.genotype), geno_filtered$TagSNP.genotype, geno_filtered$Imp.genotype)
    
    counts<-data.frame(unclass(table(as.character(geno_filtered$Inversion), geno_filtered$Genotype)))
    
    counts$HOMO <- counts$INV + counts$STD
    counts$all<-counts$HET + counts$HOMO

    colnames(counts)<- paste0(colnames(counts),".genotype")
    counts$Inversion<-rownames(counts)

    allgeno<-merge(allgeno, counts[,c("HET.genotype", "HOMO.genotype", "all.genotype", "Inversion")],all=TRUE, by = "Inversion")
    
    allgeno[which( allgeno$Result %in% c("A.Tagged" ,"A.Tag.Imput","A.Imputed") & # Previously accepted results
      !(allgeno$all.genotype > 3 &  (allgeno$HET.genotype > 0 & allgeno$HOMO.genotype > 0)) # Not enough sample
                   ), "Result"]<-"R.lowSample"

  
    
```


```{r final, echo = FALSE}
allgeno<-allgeno[,c("Inversion","Individual","Population","Result","Imputability", "Origin","Imp.probability","Imp.genotype",       "TagSNP.sequenced","TagSNP.probability", "TagSNP.population" , "TagSNP.genotype" ,   "Cov.seq.vs.exp_maf","Cov.sequenced_maf" ,"HET.genotype","HOMO.genotype","all.genotype"   )]

  # Show

       kbl(
      head(allgeno[,c(1:10)]), booktabs=T, row.names = FALSE,  caption = "Sample summary table for the results", position = "h")%>%
        kable_styling(position = "center", latex_options =c( "scale_down"))
kbl(
      head(allgeno[,c(11:17)]), booktabs=T, row.names = FALSE, position = "h")%>%
        kable_styling(position = "center", latex_options =c( "scale_down"))

```


In addition, a per-inversion summary table stored in inversions_summary.csv show how are the 20 individual results distributed regarding this inversion before applying the "R.lowSample" tag, the amount of correctly heterozygous, homozygous and total genotyped individuals, and a column indicating whether the inversion was "Accepted", "lowSample" or "unableToGenotype". 

```{r, include=FALSE}
write.csv(allgeno, file = "allgenotypes_classified.csv")

invSummary<-merge(invSummary, unique(allgeno[, c("Inversion", "HET.genotype", "HOMO.genotype", "all.genotype")]))
invSummary$Result<-"lowSample"
invSummary[which(invSummary$all.genotype > 3 &  (invSummary$HET.genotype > 0 & invSummary$HOMO.genotype > 0)), "Result"]<-"Accepted"
invSummary[which( is.na(invSummary$all.genotype ) ), "Result"]<-"unableToGenotype"

invSummary[is.na(invSummary)] <- 0

write.csv(invSummary, file = "inversions_summary.csv")

```

Figure  \@ref(fig:results) shows the incidence of each classification category. **`r nrow(allgeno[allgeno$Result %in% c(c("A.Tagged" ,"A.Tag.Imput","A.Imputed"  )) ,])` inversion-individual pairs from `r sum(invSummary$Result == "Accepted")` inversions were finally accepted for analysis**. `r sum(invSummary$Result == "lowSample")` inversions were genotyped but not in enough heterozygous or total individuals to be analyzed, and `r sum(invSummary$Result == "unableToGenotype")` couldn't be genotyped at all.

```{r results, echo = FALSE, fig.cap ="Final status of each inversion-individual pair. In most cases the imputation worked well, and almost half of the imputation results are supported by a tag SNP check. 5 pairs were recovered thanks to the tag SNP check and 18 cases have to yet be revised and are potentially useful. The main reasons for sample loss are the inversion not being imputable in the individual's population and inversions not having enough samples to compare heterozygous vs homozygous tendencies. "}

results_summary<-data.frame(table(allgeno$Result))



ggplot(results_summary,aes(x=Var1, y =Freq))+geom_bar(stat="Identity")+geom_text(aes(label=Freq), vjust = -0.25)+
  ggtitle("Incidence of each classification category")+
  labs(y = "Amount of inversion-individual pairs", x = "Category")+
   theme(axis.text.x = element_text(angle = 45, hjust = 1))
  

```

```{r results2}


invSummary<-melt(invSummary, id.vars =  c("Inversion", "HET.genotype", "HOMO.genotype", "all.genotype", "Result"))

rejectList<-invSummary[invSummary$variable == "R.badImputability" & invSummary$value == 20,"Inversion"]

invSummaryPlot<-invSummary[!(invSummary$Inversion %in% rejectList),]

sTab<-merge(aggregate(value   ~ Inversion, invSummaryPlot, max), invSummaryPlot ) 

invSummaryPlot$Inversion<-factor(invSummaryPlot$Inversion, levels =  sTab[order(sTab$variable, sTab$value), "Inversion"])

# blues<-colorRampPalette(c("#0B9885", "#A3EA99"))
# oranges<-colorRampPalette(c("#F3EB90",  "#dd6e42" ))
colors<-colorRampPalette(c("#308474", "#8cb87d","#f9d476",  "#e5ab68","#ad5757"))

invSummaryPlot$variable<-factor(invSummaryPlot$variable, levels = c("A.Tag.Imput", "A.Tagged", "A.Imputed" ,"C.Tag.Imput","R.badImputation","R.badCoverage", "R.badImputability"))

ggplot(invSummaryPlot)+geom_bar(aes(x = Inversion, y =value, fill = variable), stat="identity")+coord_flip() + facet_grid(Result ~., scales = "free", space = "free")+
  # scale_fill_brewer(palette = "Spectral", direction = -1)
  scale_fill_manual(values = c(colors(7)))
 

```



# Future directions


* An imputability assessment in EAS population will allow us to process the correspongind individuals as we did with EUR and AFR. 



<!-- # Different filters, tested.  -->


<!-- ```{r} -->

<!-- test_filter<-function(Imp.min.quality){ -->

<!--   allgeno<-merge(genotypes[,c("Inversion", "Individual", "Population", "Imputability", "Imp.min.quality", "Imp.all.equal", "Imp.genotype")], tagtab_summary[,c("Inversion", "Individual", "TagSNP.sequenced","TagSNP.probability", "TagSNP.population",  "TagSNP.genotype")], by = c("Inversion", "Individual"), all = TRUE) -->

<!--     # Get individual names for coverage table -->
<!--     covTab$IND<-sub("^\\d+\\.","",covTab$IND) -->
<!--     covTab$IND<-sub("nc", "NC", covTab$IND, ignore.case = FALSE) -->
<!--     covTab$IND<-sub("ab", "", covTab$IND, ignore.case = FALSE) -->

<!--   allgeno<-merge(allgeno, covTab[covTab$MAF == 0.025 & covTab$CI == 500000,c("IND", "INV", "seq.vs.exp_maf", "sequenced_maf")] , by.x = c("Inversion", "Individual") , by.y = c("INV", "IND"), all.x=TRUE) -->


<!-- # Set filters -->

<!--   # Good imputation =( allgeno$Imp.min.quality >= Imp.min.quality & !is.na(allgeno$Imp.genotype)) -->
<!--   # Good tagSNP =  allgeno$TagSNP.probability >=0.8  -->
<!--   # Bad coverage =  allgeno$seq.vs.exp_maf < 0.3 & allgeno$sequenced_maf < 500  -->
<!--   # Not good tag SNP = (allgeno$TagSNP.probability < 0.8 | is.na(allgeno$TagSNP.probability )) -->
<!--   # Not good imputatoin = (allgeno$Imp.min.quality  < Imp.min.quality | is.na(allgeno$Imp.min.quality )) -->

<!--   # R.badImputability -->
<!--   allgeno$Result<-NA -->
<!--   allgeno[!(allgeno$Imputability %in% accepted_tags) & # Imputation is not Tagged, not polymorphic or imputable -->
<!--             is.na(allgeno$Result) , "Result"]<-"R.badImputability" -->

<!--   # R.badCoverage -->
<!--   allgeno[which( allgeno$seq.vs.exp_maf < 0.3 & allgeno$sequenced_maf < 500 &  # Has bad coverage -->
<!--                   is.na(allgeno$Result)) , "Result"]<-"R.badCoverage" -->

<!--   # R.badImputation -->
<!--   allgeno[which(  (allgeno$Imp.min.quality  < Imp.min.quality | is.na(allgeno$Imp.min.quality )) & # Not good imputatoin -->
<!--                   (allgeno$TagSNP.probability < 0.8 | is.na(allgeno$TagSNP.probability )) &  # Not good tag SNP -->
<!--                    is.na(allgeno$Result)), "Result"]<-"R.badImputation" -->

<!--   # C.Tag.Imput -->
<!--   allgeno[which(  ( allgeno$Imp.min.quality >= Imp.min.quality & !is.na(allgeno$Imp.genotype))& # Good imputation -->
<!--                    allgeno$TagSNP.probability >=0.8 & # Good tag SNP -->
<!--                    allgeno$Imp.genotype != allgeno$TagSNP.genotype & # Imputation not equal to tag snp -->
<!--                    is.na(allgeno$Result)), "Result"]<-"C.Tag.Imput" -->

<!--   # C.check.Imput -->
<!--   allgeno[which( ( allgeno$Imp.min.quality >= Imp.min.quality & !is.na(allgeno$Imp.genotype)) & # Should be a good imputation -->
<!--                   is.na(allgeno$Imp.all.equal) & # Marked as NA in all equal because assumptions are not always met -->
<!--                   is.na(allgeno$Result)), "Result"]<-"C.check.Imput" -->

<!--   # A.Tagged -->
<!--   allgeno[which( allgeno$TagSNP.probability >=0.8 & # Good tagSNP -->
<!--                   (allgeno$Imp.min.quality  < Imp.min.quality | is.na(allgeno$Imp.min.quality )) & #Not good imputation -->
<!--                    is.na(allgeno$Result)), "Result"]<-"A.Tagged" -->

<!--   # A.Imputed -->
<!--   allgeno[which(( allgeno$Imp.min.quality >= Imp.min.quality & !is.na(allgeno$Imp.genotype))& # Good imputation -->
<!--                 (allgeno$TagSNP.probability < 0.8 | is.na(allgeno$TagSNP.probability )) & # Not good tag SNP -->
<!--                   is.na(allgeno$Result)), "Result"]<-"A.Imputed" -->

<!--   # A.Tag.Imput -->
<!--   allgeno[which( ( allgeno$Imp.min.quality >= Imp.min.quality & !is.na(allgeno$Imp.genotype)) & # Good imputation -->
<!--                   allgeno$TagSNP.probability >=0.8 & # Good tagSNP -->
<!--                   allgeno$Imp.genotype == allgeno$TagSNP.genotype & # Imputation equal to tag snp -->
<!--                   is.na(allgeno$Result)), "Result"]<-"A.Tag.Imput" -->


<!--   colnames(allgeno)[ colnames(allgeno) %in% c("seq.vs.exp_maf"  ,   "sequenced_maf" ) ]<-c("Cov.seq.vs.exp_maf", "Cov.sequenced_maf") -->



<!-- # Make inversion summary before R.lowSample -->

<!-- invSummary<-allgeno[,c( "Inversion", "Result")] -->
<!-- invSummary$counts<-1 -->
<!-- invSummary<-aggregate(counts ~ Inversion + Result,  invSummary, sum ) -->
<!-- invSummary<-dcast(invSummary, Inversion ~ Result) -->

<!-- # R.lowSample -->

<!--    geno_filtered<-allgeno[allgeno$Result %in% c("A.Tagged" ,"A.Tag.Imput","A.Imputed"  ) ,] -->

<!--     geno_filtered$Genotype<-ifelse(is.na(geno_filtered$Imp.genotype), geno_filtered$TagSNP.genotype, geno_filtered$Imp.genotype) -->

<!--     counts<-data.frame(unclass(table(as.character(geno_filtered$Inversion), geno_filtered$Genotype))) -->

<!--     counts$HOMO <- counts$INV + counts$STD -->
<!--     counts$all<-counts$HET + counts$HOMO -->

<!--     colnames(counts)<- paste0(colnames(counts),".genotype") -->
<!--     counts$Inversion<-rownames(counts) -->

<!--     allgeno<-merge(allgeno, counts[,c("HET.genotype", "HOMO.genotype", "all.genotype", "Inversion")],all=TRUE, by = "Inversion") -->

<!--     allgeno[which( allgeno$Result %in% c("A.Tagged" ,"A.Tag.Imput","A.Imputed") & # Previously accepted results -->
<!--       !(allgeno$all.genotype > 3 &  (allgeno$HET.genotype > 0 & allgeno$HOMO.genotype > 0)) # Not enough sample -->
<!--                    ), "Result"]<-"R.lowSample" -->


<!-- invSummary<-merge(invSummary, unique(allgeno[, c("Inversion", "HET.genotype", "HOMO.genotype", "all.genotype")])) -->
<!-- invSummary$Result<-"lowSample" -->
<!-- invSummary[which(invSummary$all.genotype > 3 &  (invSummary$HET.genotype > 0 & invSummary$HOMO.genotype > 0)), "Result"]<-"Accepted" -->
<!-- invSummary[which( is.na(invSummary$all.genotype ) ), "Result"]<-"unableToGenotype" -->

<!-- invSummary[is.na(invSummary)] <- 0 -->

<!-- results_summary<-data.frame(table(allgeno$Result)) -->


<!-- isplot<-unique(invSummary[c("Inversion", "Result")]) -->

<!-- results_invs<-data.frame(table(isplot$Result)) -->

<!-- return(list(results_summary, results_invs, unique(isplot[isplot$Result == "Accepted" , "Inversion"]))) -->
<!-- } -->

<!-- ```  -->


<!-- - All the same procedure, but requiring different probabilites -->

<!-- ```{r} -->

<!-- pairs<-data.frame() -->
<!-- invs<-data.frame() -->
<!-- invlist<-list() -->

<!-- for (prob in c(0.8, 0.85, 0.9, 0.95, 1)) { -->
<!--   tmp_p<- data.frame(test_filter(prob)[1]) -->
<!--   tmp_p$threshold <- prob -->
<!--   pairs<-rbind(pairs,tmp_p) -->

<!--   tmp_i<- data.frame(test_filter(prob)[2]) -->
<!--   tmp_i$threshold <- prob -->
<!--   invs<-rbind(invs,tmp_i) -->

<!--   invlist[[as.character(prob)]]<-test_filter(prob)[3] -->


<!-- } -->



<!-- factorblues<-colorRampPalette(c( '#c2e699','#41b6c4','#253494')) -->

<!-- # Evolution of pairs -->

<!-- ggplot(pairs,aes(x=Var1, y =Freq, fill = as.factor(threshold)))+geom_bar(stat="Identity", position = "dodge")+geom_text(aes(label=Freq), vjust = -0.25,  position = position_dodge(width = 1))+ -->
<!--   ggtitle("Incidence of each classification category")+ -->
<!--   labs(y = "Amount of inversion-individual pairs", x = "Category")+ -->
<!--    theme(axis.text.x = element_text(angle = 45, hjust = 1))+ -->
<!--   scale_fill_manual(values=factorblues(5)) -->

<!-- # Evolution of inversions -->

<!-- ggplot(invs,aes(x=Var1, y =Freq, fill = as.factor(threshold)))+geom_bar(stat="Identity", position = "dodge")+geom_text(aes(label=Freq), vjust = -0.25,position = position_dodge(width = 1))+ -->
<!--   ggtitle("How many inversions per group")+ -->
<!--   labs(y = "Amount of inversions", x = "Category")+ -->
<!--   scale_fill_manual(values=factorblues(5)) -->

<!-- # Which inversions did we loose? -->

<!-- setdiff(unlist(invlist$`0.8`), -->
<!-- unlist(invlist$`0.95`)) -->

<!-- ``` -->


<!-- - All panel in unique inversions; same population panel in recurrent inversions -->
<!-- Let's assume we use 0.95 filter.  -->

<!-- ```{r} -->

<!-- typeinvs<-read.table("../../data/use/inversions_info/2020-08_inversionInfo_hg38.csv", sep = "\t", header = T) -->

<!-- genotypes_save<-genotypes -->

<!-- genotypes<-merge(genotypes, typeinvs[,c("Inversion" , "Origin" )], all.x = TRUE) -->


<!-- genotypes$Imp.min.quality<-ifelse( -->
<!--                                     is.na(genotypes$Origin), genotypes$Probability_con, ifelse( -->
<!--                                     genotypes$Origin == "NH", genotypes$Probability_500, genotypes$Probability_con) -->
<!--                                     ) -->
<!-- genotypes$Imp.genotype<-ifelse( -->
<!--                                     is.na(genotypes$Origin), genotypes$Genotype_con, ifelse( -->
<!--                                     genotypes$Origin == "NH", genotypes$Genotype_500, genotypes$Genotype_con) -->
<!--                                     ) -->

<!-- prob<-0.8 -->

<!--   tmp_p<- data.frame(test_filter(prob)[1]) -->
<!--   tmp_p$threshold <- paste0(prob,"_origin") -->
<!--   pairs<-rbind(pairs,tmp_p) -->

<!--   tmp_i<- data.frame(test_filter(prob)[2]) -->
<!--   tmp_i$threshold <- paste0(prob,"_origin") -->
<!--   invs<-rbind(invs,tmp_i) -->

<!--   invlist[[as.character(paste0(prob,"_origin"))]]<-test_filter(prob)[3] -->



<!--   ggplot(pairs,aes(x=Var1, y =Freq, fill = as.factor(threshold)))+geom_bar(stat="Identity", position = "dodge")+geom_text(aes(label=Freq), vjust = -0.25,  position = position_dodge(width = 1))+ -->
<!--   ggtitle("Incidence of each classification category")+ -->
<!--   labs(y = "Amount of inversion-individual pairs", x = "Category")+ -->
<!--    theme(axis.text.x = element_text(angle = 45, hjust = 1))+ -->
<!--   scale_fill_manual(values=factorblues(7)) -->


<!--     ggplot(invs,aes(x=Var1, y =Freq, fill = as.factor(threshold)))+geom_bar(stat="Identity", position = "dodge")+geom_text(aes(label=Freq), vjust = -0.25,position = position_dodge(width = 1))+ -->
<!--   ggtitle("How many inversions per group")+ -->
<!--   labs(y = "Amount of inversions", x = "Category")+ -->
<!--   scale_fill_manual(values=factorblues(7)) -->

<!--   # Which inversions did we loose? -->

<!-- setdiff(unlist(invlist$`0.8_origin`), -->
<!-- unlist(invlist$`0.8`)) -->


<!-- #0.95_origin Perd les mateixes que el 0.95, pero recupera la 1222. Cas 1222: 2 europeus (suposadament no_polymorphic) surten HET. Tecnicament la inv té tag snps pero no els tenia a la meva llista, o sigui que ja s'arreglara.  -->


<!-- # 0.8_origin recupera la 965 que es perdia perque en un ind EAS la sample global petita no sortia HET pero la resta si, i la 1066 que tambe en un EAS surt HET en tots els samples globals pero STD en la mateixa població.  -->




<!-- ``` -->

