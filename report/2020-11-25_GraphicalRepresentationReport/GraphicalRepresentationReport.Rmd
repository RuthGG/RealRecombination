---
title: "Genotype inference analysis"
author: "Ruth GÃ³mez Graciani"
output:
  bookdown::pdf_document2:
    toc: false
    latex_engine: xelatex
  header-includes:
  - \usepackage{xcolor}
  - \usepackage{framed}


mainfont: OpenSans
---

_In this report, I make descriptive plots and statistical analyses to find whether inversion regions have a tendency to have lower recombination rates in heterozygous individuals._

```{r setup, include=FALSE}

require("ggpubr")
require("reshape2")
library("ggplot2")
require("data.table")
require("knitr")
require("stringr")
library("kableExtra")
require("gridExtra")
# Example: how to store figure
  # plotname<- "report/2020-11-25_GraphicalRepresentationReport/lineplot.200k.small.png"
  # png(filename=plotname, width = 3508/5, height = 2480/3, units = "px" )
  # plot<- annotate_figure(lineplot, top = text_grob(paste0("Log2 transformed fold changes between het. and homo in 3 groups" ), size = 10) )
  # print(plot)
  # dev.off()


```

# Origin of the data

## Genotypes

```{r genoData, include=FALSE }

# Read genotypes
genotypes <- read.table("../2020-10-28_genotypeFilteringReport/allgenotypes_classified.csv", header = TRUE, sep = ",", row.names = 1, stringsAsFactors = FALSE)

# Use tagSNP genotype if available
genotypes$Genotype<-ifelse(is.na(genotypes$TagSNP.genotype), genotypes$Imp.genotype, genotypes$TagSNP.genotype)

# Filter out and keep only those accepted genotypes
genotypes<-genotypes[genotypes$Result %in% c("A.Imputed","A.Tag.Imput","A.Tagged" ), c("Individual", "Inversion","Population", "Genotype")]



```

Genotypes were imputed in our 20 individuals using IMPUTE2, tagSNP inference or both. Genotypes' quality control report can be found in "report/2020-10-28_genotypeFilteringReport/filteringAnalysis.pdf". We obtained more than 3 high-quality genotypes coming from both homozygous and heterozygous individuals for `r length(unique(genotypes$Inversion))-2` inversions. 

<!-- OJO!! Inversion calculation is adjusted by the presence of HSInv0052 -->


## Map

```{r recmapData, include=FALSE }

# Read quantile normalized data
normData <- read.table("../../analysis/2020-10-14_09_crossovers_200k/crossoverResult_QN.txt", header = TRUE)

```

Recombination maps were calculated from recombination events in a probabilistic way. The genome is divided into windows, for which recombination rates are calculated following a probabilistic method: instead of just assuming that the crossover took place in the center of the recombination event, each event is ponderated depending on how much of it is overlapping with a window, and the sum is used to calculate cM/Mb values for each window. Then, recombination results are normalized using a quantile normalization in order to make them comparable. 

The effectivity of this method, as well as the smallest informative window size, were assessed with simulations. For each recombination event, a hypothetical actual location for the crossover was randomly selected and then the corresponding recombination rate calculated. We obtained the correlation between the simulated rates and the rates calculated with low-resolution recombination events. This gives us a measurement of how close estimated rates would be to real ones. The probabilistic method proved to be better than the center-point method, and window sizes between 150 and 200kb (corresponding to 0.9 and 0.95 correlations) would be optimal (Figure \@ref(fig:PLOTminimalWindow)). 

```{r PLOTminimalWindow, echo = FALSE, message = FALSE, fig.cap ="Real recombination rates were simulated at different window sizes and comapred with the corresponding estimated ones. According to this result, our probabilistic method is more accurate than the center-point method, and the minimum informative window size is 150-200 kb.", fig.height=1, fig.pos="!H"}

include_graphics("..//2020-11-09_minimalInformativeWindow/window_assimptote.png", dpi = NA)

```


```{r joinData, include=FALSE }

# SOLVE NAME CHANGES

# Manually search for name changes between files
# g<-unique(genotypes$Inversion)
# n<- unique(normData$inv)
# g[!g%in%intersect(g,n)]

namechanges<-read.table("../../data/use/inversions_info/2021.01.19to38nameChanges", header = TRUE, stringsAsFactors = FALSE)
rownames(namechanges)<-namechanges$hg19
genotypes[genotypes$Inversion %in% namechanges$hg19, "Inversion"]<-namechanges[genotypes[genotypes$Inversion %in% namechanges$hg19, "Inversion"],"hg38"]

# SOLVE DEL GENOTYPES
# Adjust genotypes from si, sd , id
# inv52<-genotypes[genotypes$Inversion %in% c("HsInv0052id" ,"HsInv0052sd" ,"HsInv0052si" ),]
# inv52<-reshape(inv52, idvar = c("Individual", "Population"), timevar = "Inversion", direction = "wide")

# MERGE  DATA
normGenoData<-merge(genotypes,normData, by.x =c("Individual", "Inversion" ), by.y =  c("ind", "inv")  )

# EXCLUDE DATA IF NEEDED
normGenoData<-normGenoData[!(normGenoData$Inversion %in% c("HsInv0052id" ,"HsInv0052sd" ,"HsInv0052si" )),]

```

# Descriptive analysis

```{r invinfoData, include=FALSE }

    invinfo<-read.table("../../data/use/inversions_info/2020-08_inversionInfo_hg38.csv", sep = "\t", header = TRUE, stringsAsFactors = FALSE)
  invsizes<-read.table("../../data/use/inversions_info/2020.07.inversions_hg38.csv", sep = "\t", header = FALSE, stringsAsFactors = FALSE)
  
  invinfo$Size<-NULL
  invsizes$Size<-invsizes$V6-invsizes$V3-1
  invsizes$SizeIn<-invsizes$V5-invsizes$V4-1

  invinfo<-merge(invinfo, invsizes, by.x = "Inversion", by.y = "V2", all = TRUE)
  invinfo<-invinfo[,c("Inversion", "Origin", "Size", "SizeIn")]
  

  
  # THIS IS WHERE I SET THE GROUPS!

      invinfo$Group.0.75<-ifelse(invinfo$Size > 24000, "Big", "Small")
      invinfo$Group.0.5<-ifelse(invinfo$Size > 9000, "Big", "Small")

  

```

```{r tidyDataFun, include =  FALSE }

# FUNCTION TO MAKE TIDY DATA
# Input: normGenoData table, inversions info table with anything relevant. At least the size!
# Options:
  # aggregateWins =  do I want to analyze inside-inversion windows separated or aggregated? separated: by-inversion detail plots; aggregated: summaries
  # aggregateInvs =  do I want to have one line per inversion with HET and HOMO means (aggregated), or one result per individual-inversion pair (separated)?


tidyData<-function(data=normGenoData, info = invinfo, aggregateWins , aggregateInvs){

  # Generate clean HET/HOMO tag
    normGenoData$Haplotype<-ifelse(normGenoData$Genotype %in% c("INV", "STD"), "Homozygous" , "Heterozygous")


  # aggregateWins

    if (aggregateWins == TRUE){
      # Windows aggregated by mean, with position from start to end of all the region

      # Value
      partn<-aggregate(cM.Mb.QN  ~  Inversion + Haplotype +position+Individual ,  normGenoData[normGenoData$position == "inv",], mean)
      # Start position
      parts<-aggregate(startWin  ~  Inversion + Haplotype +position+Individual ,  normGenoData[normGenoData$position == "inv",], min)
      # End position
      parte<-aggregate(endWin  ~  Inversion + Haplotype +position+Individual ,  normGenoData[normGenoData$position == "inv",], max)
      # Merge all 3 tables
      part<-merge(partn, merge(parts, parte))
      # Add window ID
      part$idWin<-paste(part$Inversion, "inv_1", sep="_" )

      # Join aggregated inversions with colindant windows
      toPlot<-rbind(normGenoData[normGenoData$position != "inv", colnames(part)], part)

    }else{
      # Use info as-is
      toPlot<-normGenoData
    }

  # aggregateInvs

    if (aggregateInvs == TRUE){
      # Aggregate by zygosity to make the two sides of the comparison
        # Mean value
        test.subset<-aggregate(   cM.Mb.QN  ~  Inversion + startWin+endWin + Haplotype +idWin,toPlot, mean)
        # Count of individuals
        toPlot$counts<-1
        test.counts<-aggregate(   counts  ~  Inversion + startWin+endWin + Haplotype +idWin,toPlot, sum)
        test.subset<-merge(test.subset, test.counts)

      # Make both tables wide
        # Counts table wide
        test.subset.counts<-reshape2::dcast(test.subset, Inversion + startWin + endWin + idWin  ~ Haplotype, value.var="counts")
        colnames(test.subset.counts)[colnames(test.subset.counts) %in% c( "Heterozygous", "Homozygous"  )]<-
          c("Heterozygous.counts", "Homozygous.counts"  )
        # CM.Mb table wide
        test.subset.values<-reshape2::dcast(test.subset, Inversion + startWin + endWin + idWin  ~ Haplotype, value.var="cM.Mb.QN")
        colnames(test.subset.values)[colnames(test.subset.values) %in% c( "Heterozygous", "Homozygous"  )]<-
          c("Heterozygous.cM.Mb.QN", "Homozygous.cM.Mb.QN" )

      # Merge wide table
        test.subset.wide<-merge(test.subset.counts, test.subset.values)

      # Make comparisons
        # Difference
        test.subset.wide$Means.Difference<- test.subset.wide$Heterozygous.cM.Mb.QN - test.subset.wide$Homozygous.cM.Mb.QN
        # Fold changes
        test.subset.wide$Means.Fold.Change<- test.subset.wide$Heterozygous.cM.Mb.QN / test.subset.wide$Homozygous.cM.Mb.QN
        # Fold changes log
        test.subset.wide$Means.Fold.Changelog<- log2(test.subset.wide$Means.Fold.Change)

      # Discard those without data
        test.subset.wide<-  test.subset.wide[!is.na(test.subset.wide$Means.Difference),]
    }else{
      # Use info as-is
      test.subset.wide<-toPlot
    }


  # Order table and factors

      # Relative positions and window IDs
      test.subset.wide[c("side", "relpos")]<-str_split_fixed(test.subset.wide$idWin, "_", 3)[,c(2,3)]
      test.subset.wide[c("winPos")]<-str_split_fixed(test.subset.wide$idWin, "_", 2)[,2]

      test.subset.wide$side<-factor(test.subset.wide$side, levels = c("left", "inv", "right"))
      test.subset.wide$relpos<-as.numeric(test.subset.wide$relpos)

      test.subset.wide<-test.subset.wide[order( test.subset.wide$side, test.subset.wide$relpos),]
      test.subset.wide$winPos<- factor(  test.subset.wide$winPos, levels = unique(  test.subset.wide$winPos))


  # Add relevant inversion info

      test.subset.wide<-merge(test.subset.wide, invinfo, all.x = TRUE)

      return(test.subset.wide)

}

# testFF<-tidyData(aggregateWins = F, aggregateInvs = F)
# testFT<-tidyData(aggregateWins = FALSE, aggregateInvs = T) # >1 window per inversion, 1 row per inversion window
# testTF<-tidyData(aggregateWins =T, aggregateInvs = FALSE) # 1 window per inversion, 1 row per inversion-window-individual
testTT<-tidyData(aggregateWins = T, aggregateInvs = T) # 1 window per inversion,1 row per inversion window

```

## Inversion groups

It could be that inversions with different sizes show different behaviors. To account for that, I want to divide inversions in two groups of size. There is a bias in the distribution of genotyped inversions when compared with all the available inversions because small ones tend to be NH-generated and unique and big ones to be NAHR-generated and thus probably recurrent, making small inversions more likely to be correctly genotyped (Figure \@ref(fig:PLOTgroupSelection)). Thus, I decided to calculate the classification thresholds from the original distribution rather than the genotyped inversions distribution, which would return skewed thresholds.

I tested two classification thresholds, the median and the 3rd quantile, rounded to 9kb and 24kb. Table  \@ref(tab:TABgroupSummary)) shows some basic information about the groups

<!-- # CHANGE GROUP SIZE ACCORDING IN invinfoData TO THIS ANALYSIS! -->

```{r PLOTgroupSelection, echo = FALSE, fig.cap ="Size distributions (log transformed) for all the available inversions (expected) and for the actually genotyped inversions. Small inversions are genotyped proportionally to the original distribution while big inversions are less often correctly genotyped, probably because they tend to be NAHR-mediated, recurrent inversions. This changes in distribution generates a big bias in the median and 3rd quantile, so the thresholds were calculated using the expected distribution.", fig.pos="!H"}



expected <- data.frame(size =invinfo$Size ,logsize = log(invinfo$Size), source = "expected")
genotyped<-data.frame(size=unique(testTT[,c("Size", "Inversion")])$Size, logsize=(log(unique(testTT[,c("Size", "Inversion")])$Size)), source = "genotyped")

sizeComp<-rbind(expected, genotyped)                      

# MEDIAN TEST
sizeComp.median<-data.frame(median = c(median(expected$size), median(genotyped$size)), logmedian = c(log(median(expected$size)),log(median(genotyped$size))), source = c("expected", "genotyped") )
   
# 75% TEST
sizeComp.quant4<-data.frame(median = c( quantile(expected$size, 0.75), quantile(genotyped$size, 0.75) ), 
                            logmedian = c(log(quantile(expected$size, 0.75)), log(quantile(genotyped$size,0.75)) ), source = c("expected", "genotyped") )



ggplot(sizeComp, aes(x = logsize))+geom_histogram(bins = 10)+facet_wrap(.~source , scales = "free")+
  geom_text(data=sizeComp.median, aes(x = Inf, y = +Inf, label = paste0("median= ", median) ) , vjust = 1.1, hjust = 1.1, color = "red")+
  geom_vline(data = sizeComp.median, aes(xintercept = logmedian), color = "red")+
  geom_text(data=sizeComp.quant4, aes(x = Inf, y = +Inf, label = paste0("3rd quartile= ", median) ) , vjust = 3.1, hjust = 1.1, color = "blue")+
  geom_vline(data = sizeComp.quant4, aes(xintercept = logmedian), color = "blue")

  

```

```{r TABgroupSummary, echo = FALSE,  message = FALSE, warning = FALSE}

sub<-unique(testTT[,c("Group.0.5", "Group.0.75", "Size")])

# MEDIAN THRESHOLD

counts<-data.frame(table(sub$Group.0.5))
colnames(counts)<-c("Group", "n.Invs")
counts$minsize<-aggregate(Size ~ Group.0.5, data= sub, min)$Size
counts$maxsize<-aggregate(Size ~ Group.0.5, data= sub, max)$Size

counts.0.5<-counts

#  0.75 THRESHOLD

counts<-data.frame(table(sub$Group.0.75))
colnames(counts)<-c("Group", "n.Invs")
counts$minsize<-aggregate(Size ~ Group.0.75, data= sub, min)$Size
counts$maxsize<-aggregate(Size ~ Group.0.75, data= sub, max)$Size

counts.0.75<-counts

counts<-merge(counts.0.5, counts.0.75, by = "Group", suffixes = c("", ""))
  # Show
   kbl(
     counts, booktabs=T, row.names = FALSE, caption = "Basic information for the two group sizes in which inversions were divided", position = "h")     %>%
        kable_styling(position = "center")%>%
        add_header_above( c(" " = 1, "Median" = 3, "3rd Quantile" = 3))


```

## Recombination rate differences

The selected window size is bigger than most inversions. In those cases that the inversion spans more than one window, we made the mean of the windows. 
<!-- > A plot with inversion size distribution and window threshold, with percentages. This shows the % of invs bigger and smaller than the window size, and how much bigger or smaller they are.
```{r PLOTwindowVSinvSize, echo = FALSE, message = FALSE, fig.cap ="The optimal minimum informative window size is 150-200 kb, but this is much larger than most of the available inversions.", fig.height=1}
ggplot(testTT)+geom_point(aes(x = (Size), y = Inversion))+geom_vline(xintercept = (200000))
```
-->
Then, for each inversion, the mean values for heterozygous and homozygous individuals was calculated and to compared both gorups with the fold change (log2(Homozygous/Heterozygous)). 

**HsInv0325 was considered an outlier for now.**


```{r removeOutlier, include = FALSE}

# without outlayer
testTT<-testTT[testTT$Inversion != "HsInv0325", ]
```

```{r PLOTlineplot, echo = FALSE, fig.cap ="Line plots showing tendencies for big and small inversions, using two thresholds to define the categories. HsInv0325 was considered an outlier and removed", message = FALSE, warning = FALSE, fig.pos="!H"}

# Lineplot
lineplot0.5<-ggplot(testTT[testTT$relpos <2,])+geom_line(aes(x = winPos, y = Means.Fold.Changelog, group = Inversion), color = "steelblue4")+
         facet_grid(Group.0.5 ~ . ) +
         # geom_text(data = testTT[testTT$winPos == "inv_1", ] , aes(x = winPos, y = Means.Fold.Changelog, label = Inversion) )+
  geom_hline(yintercept = 0, color = "red", alpha = 0.75)+
  ggtitle("Median size threshold")

lineplot0.7<-ggplot(testTT[testTT$relpos <2,])+geom_line(aes(x = winPos, y = Means.Fold.Changelog, group = Inversion), color = "steelblue4")+
         facet_grid(Group.0.75 ~ . ) +
         # geom_text(data = testTT[testTT$winPos == "inv_1", ] , aes(x = winPos, y = Means.Fold.Changelog, label = Inversion) )+
  geom_hline(yintercept = 0, color = "red", alpha = 0.75)+
  ggtitle("3r Quartile size threshold")

grid.arrange(lineplot0.5, lineplot0.7, nrow = 1)
```




```{r PLOTpositiveNegative, echo = FALSE, fig.cap ="Amount of cases with Heterozygous > Homozygous and viceversa.", fig.pos="!H"}

# Remember! Het/Homo

testTable<-testTT[testTT$side == "inv",]

testTable$difgroup<-ifelse(testTable$Means.Fold.Changelog>0, "HET > HOM", "HET < HOM" )

barplots0.5<-ggplot(testTable)+geom_bar(aes(x = Group.0.5, fill = difgroup), position = "dodge")+
  ggtitle("Median size threshold")
barplots0.7<-ggplot(testTable)+geom_bar(aes(x = Group.0.75, fill = difgroup), position = "dodge")+
  ggtitle("3rd Quartile size threshold")

ggarrange(barplots0.5, barplots0.7, nrow = 1, legend = "bottom",common.legend = TRUE)

```

```{r PLOTboxplot, echo = FALSE, fig.cap ="Box plots showing tendencies for big and small inversions, using two thresholds to define the categories. HsInv0325 was considered an outlier and removed", message = FALSE, warning = FALSE, fig.pos="!H"}

# Boxplot
  
 boxplot0.5<- ggplot(testTT[testTT$winPos == "inv_1",], aes(y = Means.Fold.Changelog, x = Group.0.5))+
    geom_boxplot(outlier.size =  -Inf )+
    geom_jitter( width = 0.1)+
    ggtitle("Median size threshold")
 
   
 boxplot0.7<- ggplot(testTT[testTT$winPos == "inv_1",], aes(y = Means.Fold.Changelog, x = Group.0.75))+
    geom_boxplot(outlier.size =  -Inf )+
    geom_jitter( width = 0.1)+
    ggtitle("3r Quartile size threshold")
  
 
grid.arrange(boxplot0.5, boxplot0.7, nrow = 1)

```


```{r PLOTcorrelation, echo = FALSE, fig.cap ="Correlation between log transformed size and fold change after removing outliers.", message = FALSE, warning = FALSE, fig.pos="!H"}

# Correlation
testTT$logSize<-log(testTT$Size)

ggpubr::ggscatter(testTT[testTT$winPos == "inv_1"  , ], x = "logSize", y = "Means.Fold.Changelog",
          add = "reg.line",                                 # Add regression line
          conf.int = TRUE,                                  # Add confidence interval
          add.params = list(color = "blue",
                            fill = "lightgray"),
          title = "Median size threshold"
          )+
  stat_cor(method = "pearson", label.x.npc = 0, label.y.npc = 1 )

```

\newpage

# Statistical analysis







<!-- ```{r ttest} -->
<!-- # CHUNK 4 -->

<!-- # Statistical test with only info within inversion region -->

<!-- insides<-toPlot[toPlot$position == "inv",] -->

<!-- stat_results<-data.frame(Inversion = character(), -->
<!--                          n.Homozygous = integer(), -->
<!--                          n.Heterozygous = integer(), -->
<!--                          b.pval= double(), -->
<!--                          t.pval = double(), -->
<!--                          stringsAsFactors = FALSE ) -->


<!-- for (inv in unique(insides$inv)){ -->
<!--   oneinv<-insides[insides$inv == inv,] -->
<!--   Data<-data.frame(Group=oneinv$Haplotype, Value = oneinv$cM.Mb.QN) -->

<!--   nhom<-sum(Data$Group == "Homozygous") -->
<!--   nhet<-sum(Data$Group == "Heterozygous") -->

<!--   if(nhom >= 2 & nhet >=2){ -->
<!--     # Barlett test -->
<!--     btest<-bartlett.test(Value ~ Group, data=Data) -->

<!--     if(btest$p.value >= 0.05){ -->
<!--       test<-t.test(Value ~ Group, data=Data, -->
<!--          var.equal=TRUE, -->
<!--          conf.level=0.95) -->
<!--     }else{ -->
<!--       test<-t.test(Value ~ Group, data=Data, -->
<!--          var.equal=FALSE, -->
<!--          conf.level=0.95) -->
<!--     } -->

<!--     pval<-test$p.value -->
<!--     bval<-btest$p.value -->
<!--     # library(lattice) -->
<!--     # -->
<!--     # histogram(~ Value | Group, -->
<!--     #           data=Data, -->
<!--     #           layout=c(1,2)      #  columns and rows of individual plots -->
<!--     #           ) -->
<!--     # -->
<!--     # boxplot(Value ~ Group, -->
<!--     #         data = Data, -->
<!--     #         ylab="Value") -->
<!--   }else{ -->
<!--     bval<-NA -->
<!--     pval<-NA -->
<!--   } -->
<!--   row <- c(inv, nhom ,nhet,bval, pval) -->
<!--   stat_results[nrow(stat_results)+1,]<-row -->
<!-- } -->

<!-- stat_results<-merge(stat_results, invinfo[,c("Group", "inv", "size")], by.x = "Inversion", by.y = "inv") -->

<!-- stat_results$t.pval <- as.numeric(stat_results$t.pval) -->

<!-- ggplot(stat_results)+geom_boxplot(aes(x = Group, y = t.pval))+geom_point(aes(x = Group, y = t.pval)) -->

<!-- ggplot(stat_results)+geom_point(aes(x = log(size), y = t.pval)) -->

<!-- stat_results$logsize<-log(stat_results$size) -->

<!--   ggscatter(stat_results, x = "logsize", y = "t.pval", -->
<!--           add = "reg.line",                                 # Add regression line -->
<!--           conf.int = TRUE,                                  # Add confidence interval -->
<!--           add.params = list(color = "blue", -->
<!--                             fill = "lightgray") -->
<!--           )+ -->
<!--   stat_cor(method = "pearson", label.x = 5, label.y = 1.1) -->

<!-- # oneinv<-insides[insides$inv == "HsInv0290",] -->
<!-- # Data<-data.frame(Group=oneinv$Haplotype, Value = oneinv$cM.Mb.QN) -->

<!-- # # Barlett test -->
<!-- # bartlett.test(Value ~ Group, data=Data) -->
<!-- ### If p-value >= 0.05, use var.equal=TRUE below -->

<!-- # t.test(Value ~ Group, data=Data, -->
<!-- #        var.equal=TRUE, -->
<!-- #        conf.level=0.95) -->



<!-- M1  = 0.006811897                      # Mean for sample 1 -->
<!-- M2  = 0.010633379                      # Mean for sample 2 -->
<!-- # aggregate( Value ~ Group , Data, sd) -->
<!-- S1  =  0.003025116                      # Std dev for sample 1 -->
<!-- S2  =  0.003303599                     # Std dev for sample 2 -->

<!-- Cohen.d = (M1 - M2)/sqrt(((S1^2) + (S2^2))/2) -->

<!-- library(pwr) -->

<!-- pwr.t.test( -->
<!--        n = NULL,                   # Observations in _each_ group -->
<!--        d = Cohen.d, -->
<!--        sig.level = 0.05,           # Type I probability -->
<!--        power = 0.90,               # 1 minus Type II probability -->
<!--        type = "two.sample",        # Change for one- or two-sample -->
<!--        alternative = "two.sided") -->




<!-- ``` -->


```{r chisqTest, echo = FALSE}

print("Chi squared test using Median threshold")

Matriz = as.matrix(table( testTable$difgroup, testTable$Group.0.5))
Matriz
chisq.test(Matriz,
           correct=TRUE)

print("------------------------------------------------")

print("Chi squared test using 3rd Quartile threshold")

Matriz = as.matrix(table( testTable$difgroup, testTable$Group.0.75))
Matriz
chisq.test(Matriz,
           correct=TRUE)


```
