---
title: "Inversions heterozygosis-related increase in chromosomal aberrations"
author: "Ruth GÃ³mez Graciani"
output:
  bookdown::pdf_document2:
    toc: false
    latex_engine: xelatex
header-includes:
  \usepackage{float}
  \floatplacement{figure}{H}
--- 

<!-- https://benjaminlouis-stat.fr/en/blog/2020-05-21-astuces-ggplot-rmarkdown/ -->


```{r, include=FALSE}
if (!require("pacman")) install.packages("pacman")
pacman::p_load(ggplot2, ggpubr)

# set conditions for code output
knitr::opts_chunk$set(message=FALSE, warning=FALSE, error=FALSE,fig.pos = "!H")
showcode=FALSE #for include or echo - echo=showcode // include=showcode
runbash=FALSE # for eval=runbash
runR=TRUE #for eval=runR
```


_In this report, I analyze the realtionship between the amount of chromosomes in heterozygosis and amount of aneuploidies, which is key to distinguish whether the observed reduction in crossover rate in heterozygotes is due to a physical impediment of recombination, or due to a generation of aberrations and later discard from the crossover dataset._

```{r setup, echo=showcode, eval=runR}

# Genotype and recombination info -> normGenoData
load("../2020-11-25_GraphicalRepresentationReport/normGenoData.RData")

# Inversion physical size
  invsizes<-read.table("../../data/use/inversions_info/2020.07.inversions_hg38.csv", 
                       sep = "\t", header = FALSE, stringsAsFactors = FALSE)
  
  invsizes$Size<-invsizes$V6-invsizes$V3-1

  invsizes<-invsizes[, c("V2","V3", "V6", "Size")]
  colnames(invsizes)<-c("Inversion","start", "end", "Size")
  
# Incorporate size info to genotype and recombination info
  normGenoData<-merge(normGenoData, invsizes)
  
# Amount of aneuploidies
  aneuploidies<-read.table("../../data/use/avery_aneuploidies/aneuploidycountsperdonorperchromosome.txt", header = T)

# Normalization factors 
  
   numofcells<-read.table("../../data/use/avery_crossovers/numOfCells.txt")
   crossovers<-read.table("../../data/use/avery_crossovers/allcrossovers_center.bed", header = TRUE)
   
   # Chrossovers per cell in all the individual
   normalization<-merge(numofcells, data.frame(table(crossovers$donor)  ), by.x = "V1", by.y = "Var1")
   colnames(normalization)<-c("donor", "cells",  "crossovers")
   normalization$xpercell<-normalization$crossovers/normalization$cells
   
   # Chrossovers per chromosome
   normalization.c<-merge(numofcells, data.frame(table(crossovers$donor, crossovers$chr)  ), by.x = "V1", by.y = "Var1")
   colnames(normalization.c)<-c("donor", "cells", 'chr', "crossovers")
   normalization.c$xperchr<-normalization$crossovers/normalization$cells

   chromnames<-paste0("chr", c(1:22))
```

# Introduction

There are two possible mechanisms that can lead to recombination reduction between opposite orientations of an inversion:

* A physical impediment to pair or recombine.
* Purifying selection against the unbalanced results of a crossover between orientations. 

In Bell et al. (2020), they sequence 900 to 2000 gametes from 20 donors, and then the sequenced chromosomes have 3 possible fates:

* Halthy chromosome: goes to the crossover dataset and it is used to elaborate single-individual crossover maps.
* Chromosome with small and medium aberrations: it is discarded.
* Whole chromosome and chromosome arm gains and losses: they are counted in the aberration dataset. 

We observe a reduction in crossover rate in heterozygotes compared to homozygotes, but due to the methodology in Bell et al. 2020, this is not enough to confirm whether the inhibition mechanism is physical inhibition or purifying selection. However, we can complement that observation with the measurement of alterations in the aberration count caused by inversions in heterozygosis. If more heterozygous inversions leads to more aberrations in that chromosome, that would be consistent with a purifying selection scenario. 

# Variables to test

As per the independent variable, I initially measured, on each chromosome and individual, how many centiMorgans were affected by inversions in heterozygosis as a proxy of the probability of having an aberration-generating crossover. In addition, I selected some inversion subsets that may have a larger impact in the aberration count: 

* Inversions near the centromere will form a very large acentric spanning almost all the chromosome arm, so we expect them to influence the number of chromosome arm losses. I counted as centromeric regions the 20% of each arm next to the centromere, since any inversion in that region would cause an acentric of at least ~80% of the arm. 
* Inversions near the telomere will form a very small acentric fragment, but if the dicentric fragment breaks near the centromere, the results of the crossover will be a chromosome arm gain and a chromosome arm loss. In addition, these regions concentrate most of the crossovers in the cromosome. I counted as telomeric regions the same regions we selected based on recombination density in the population-based recombination map analysis. 
* Big inversions represent a highest chance of crossover just by probability, and we observed a consistent reduction in crossovers in heterozygotes compared to homozygotes. All those discarded crossovers could be contributing to the aberration count. I considered as big inversions those that span more than 1 window in the single-individual crossover maps (>200 kb).

```{r sections, echo=showcode, eval=runR, fig.cap="The selection of inversion subsets. The map windows that contain the inversion are marked in as dark gray lines (or red for big inversions), and also with points for easier visualization. Inversions within the green region are considered to be near the centromere. Inversions within the blue region are considered to be near the telomere." ,  fig.height=6}
# I want to make a "big inversion" dataset and a "near centromere" dataset and a "near telomere" dataset

chromSizes<-read.table("../../../20211117_PopRecombination/report/20220519_tutorialLogisticModel/afterMeetingWindows/data/windows.txt", header = T)
chromSizes$Chromosome<-factor(chromSizes$Chromosome, levels = chromnames)
invcoor<-unique(normGenoData[normGenoData$position == "inv",c("Inversion", "chrWin", "startWin", "endWin")])
colnames(invcoor)[2]<-"Chromosome"

# NEAR CENTROMERE DATASET <- Calculate the 80% from telomere to centromere
closeCen<-data.frame()
closeCenInvs<-data.frame()
for(c in unique(chromSizes$Chromosome)){
  csubset<-chromSizes[chromSizes$Chromosome == c,]
  if("centromeric" %in% csubset$ChrRegion){
    s1<-min(csubset[csubset$ChrRegion == "telomeric", "Start"])
    e1<-min(csubset[csubset$ChrRegion == "centromeric", "End"])
    s2<-max(csubset[csubset$ChrRegion == "centromeric", "Start"])
    e2<-max(csubset[csubset$ChrRegion == "telomeric", "End"])
    
    start<-s1+((e1-s1+1)*0.8)-1
    end<-s2+((e2-s2+1)*0.2)-1
  } else{
    s1<-min(csubset$Start)
    e1<-min(csubset$End)
    
    start <- s1
    end<- s1+((e1-s1+1)*0.2)-1
  }
  closeCenInvs<-rbind(closeCenInvs,invcoor[invcoor$Chromosome == c & invcoor$startWin >= start & invcoor$endWin <= end,])
  closeCen<-rbind(closeCen, data.frame(Chromosome = c,Start =  start, End = end))
}

names.closeCenInvs<-unique(closeCenInvs$Inversion)


# BIG INVERSION DATASET <- all those with >1 window
names.bigInvs<-unique(invcoor[duplicated(invcoor$Inversion),"Inversion"])

# NEAR TELOMERE DATASET
# Inversions overlapping with "telomeric" 
tregions<-chromSizes[chromSizes$ChrRegion == "telomeric",]

names.closeTelInvs<-unique(unlist(apply(tregions, 1, function(x){
  invcoor[invcoor$Chromosome == x["Chromosome"] & invcoor$endWin  <= x["End"] & invcoor$startWin >= x["Start"],"Inversion"]
})))

# PLOT

ggplot()+
  geom_rect(data=chromSizes, aes(xmin = Start, xmax = End, ymin = 0, ymax = 1), alpha=0.1, fill = "black" )+
  geom_rect(data=chromSizes[chromSizes$ChrRegion == "telomeric",], aes(xmin = Start, xmax = End, ymin = 0, ymax = 1, fill = ChrRegion), alpha=0.5 )+
  facet_grid(Chromosome~.)+
  # geom_rect(data = invcoor, aes(xmin = startWin, xmax = endWin, ymin = 0.25, ymax = 0.75))+
  geom_rect(data=closeCen, aes(xmin = Start, xmax = End, ymin = 0, ymax = 1), alpha = 0.5, fill = "aquamarine2")+
  geom_point(data =invcoor, aes(x = (endWin+startWin+1)/2, y = 0.5), size = 1)+
  geom_rect(data =invcoor, aes(xmin = startWin, xmax = endWin , ymin = 0.3, ymax = 0.7))+
  geom_rect(data =invcoor[invcoor$Inversion %in% names.bigInvs,], aes(xmin = startWin, xmax = endWin , ymin = 0.3, ymax = 0.7), fill = "red")+
  xlab("")+ylab("")+theme(legend.position = "none")+
  theme(strip.text.y.right = element_text(angle = 0))+
  ggtitle("The subsets of inversions ")




```



As a dependent variable, I used the number of arm gains and arm losses, which are the types of aberrations expected to be influenced by the independent variable. 

In our fist attempts in this analysis I made some correlations, however, as it will be shown later, a big portion of cases had 0 heterozygous inversions and/or 0 aberrations detected, so I opted for converting them into binomial variables and comparing absence and presence of each.


# Results

```{r analysisTable,  echo=showcode, eval=runR}
# Calculate cM inside inversions for each inversion-individual pair

  # Take only inside inversion windows
  inData<-normGenoData[ normGenoData$position == "inv" ,]

  # Calculate percentage of overlap between window and inversion
  inData$percOverlap<-inData$Size / 200000

  inData$percOverlap<- ifelse(inData$percOverlap > 1,  # si el porcentaje de overlap es >1 (la inversion es muy grande)
           ifelse(inData$start > inData$startWin, (inData$endWin - inData$start +1 ) / 200000 # principio de inversion grande
                  , ifelse(inData$end < inData$endWin, (inData$end - inData$startWin +1 ) / 200000 # final de la inv grande
                           , 1)) # enmedio de la inv grande
           , inData$percOverlap)

 # Calculate cM in original 200kb window from normalized recRate
  inData$cM.QN<-  50*log(1/(1-(2*(inData$cM.Mb.QN * (200000/1000000)))))

  # Take the percentage of window that spans the inversion
  inData$cM.QN.inv<-inData$cM.QN * inData$percOverlap

  # Make the sum for each inversion and individual
  inData_bypair<-aggregate(cM.QN.inv  ~ Inversion+Individual+Genotype+Size+chrWin,   data=inData, sum)

# Calculate expected or theoretical cM for each inversion based on homozygotes
  GenSizeInvs<-aggregate( cM.QN.inv ~ Inversion , inData_bypair[inData_bypair$Genotype != "HET",], sum)

# Now I want to make a table with measurements for each ind and chr, and for each dataset
centiCounts<-data.frame()
  for(p in unique(inData_bypair$Individual)){
    hetfor<-inData_bypair[inData_bypair$Individual == p & inData_bypair$Genotype == "HET",c("Inversion", "chrWin")]
    hetfor<-merge(hetfor, GenSizeInvs)
    
    colList<-list()
    
    all<-data.frame(table(hetfor$chrWin))
    all<-merge(all, aggregate(cM.QN.inv ~ chrWin, hetfor, sum), by.y = "chrWin", by.x = "Var1", all = T)
    colnames(all)<-c("chrWin","count.all", "cM.QN.sum.all")
    colList[["all"]]<- all
    
    namesList<-list("centro" = names.closeCenInvs, "telom"= names.closeTelInvs, "big" = names.bigInvs)
    for (names in c("centro", "telom", "big")){
      countvec<-data.frame(table( hetfor[hetfor$Inversion %in% namesList[[names]], "chrWin"  ]))
      if(nrow(hetfor[hetfor$Inversion %in% namesList[[names]],])> 0){
        vec<-merge(countvec, aggregate(cM.QN.inv ~ chrWin, hetfor[hetfor$Inversion %in% namesList[[names]],], sum), by.x = "Var1", by.y = "chrWin", all = T)
      }else{
        vec<-countvec
        vec$v3<-0
      }
      colnames(vec)<-c("chrWin",paste0("count.", names), paste0("cM.QN.sum.",names))
      colList[[names]]<-vec
    }

    merged<-Reduce(function(x, y) merge(x, y, all=TRUE), colList)  
    merged$Individual<-p
    centiCounts<-rbind(centiCounts, merged)
  }
  

# And finally I merge it with aneuploidies and normalization
TestDataset<-merge(aneuploidies, normalization.c, all.y = T)
TestDataset<-merge(TestDataset, centiCounts, by.x = c("donor", "chr"), by.y = c("Individual", "chrWin"), all.x = T)
TestDataset[is.na(TestDataset)]<-0
TestDataset<-TestDataset[TestDataset$donor != "all",]
TestDataset$chr <- factor(TestDataset$chr, levels = chromnames)

# To long format JIC
sumnames<-paste0("cM.QN.sum.", c("all", "centro", "telom", "big"))
countnames<-paste0("count.", c("all", "centro", "telom", "big"))
TestDataset.long<-reshape2::melt(TestDataset, id.vars =c("donor", "chr", "cells", "crossovers", "xperchr", sumnames, countnames) )

colnames(TestDataset.long)[colnames(TestDataset.long) %in% c("variable", "value")]<-c("TypeOfAberration", "NumOfAberrations")

TestDataset.long<-reshape2::melt(TestDataset.long, id.vars = c("donor", "chr", "cells", "crossovers", "xperchr","TypeOfAberration", "NumOfAberrations", countnames))
colnames(TestDataset.long)[colnames(TestDataset.long) %in% c("variable", "value")]<-c("InvSubset.sum", "cM.Mb.sum")

TestDataset.long<-reshape2::melt(TestDataset.long, id.vars = c("donor", "chr", "cells", "crossovers", "xperchr","TypeOfAberration", "NumOfAberrations", "InvSubset.sum", "cM.Mb.sum"))
colnames(TestDataset.long)[colnames(TestDataset.long) %in% c("variable", "value")]<-c("InvSubset.count", "Inv.count")

TestDataset.long<-TestDataset.long[ gsub("cM.QN.sum.", "", TestDataset.long$InvSubset.sum) == gsub("count.", "", TestDataset.long$InvSubset.count),  ]


###CLEANUP
rm(all, aneuploidies, centiCounts, chromSizes, closeCen, closeCenInvs, colList, countvec , crossovers, csubset, GenSizeInvs, hetfor, inData, inData_bypair, invcoor, invsizes, merged, namesList, normalization, normalization.c, normGenoData, numofcells, tregions, vec )
```


## Data visualization

```{r,  echo=showcode, eval=runR,  fig.cap="", fig.width = 11, fig.asp = 1}
pacman::p_load(dplyr,tidyr)

# To detect outliers in number of aberrations
####ABERRATIONS
plottable<-TestDataset.long[TestDataset.long$TypeOfAberration %in% c("totalStructuralVariants", "totalWholeAneuploidies", "totalArmLevelStructuralVariants", "totalArmLosses", "totalArmGains") & TestDataset.long$InvSubset.sum == "cM.QN.sum.all",]
plottable$TypeOfAberration<-droplevels(plottable$TypeOfAberration)
# To detect COUNT OUTLIERS in DONORS

plottable.b<- count(plottable, donor,  NumOfAberrations, TypeOfAberration) %>% 
  complete(donor,  NumOfAberrations, TypeOfAberration, fill = list(n = 0))

pA<-ggplot(plottable.b[plottable.b$donor!="all",], aes(x = factor(donor), y = n, fill = factor(NumOfAberrations))) +
  geom_col(position = position_dodge()) +
  # geom_text(aes(label = n, y = n), vjust = -0.5, position = position_dodge(width=.9), size = 3)+
  facet_wrap(TypeOfAberration~., ncol = 1)+guides(fill = guide_legend(nrow = 1))+
  ggtitle("Distribution of aberrations among donors")+
  ylab("")+xlab("Donor")+scale_fill_discrete(name = "Number of aberrations")

plottable.c<-count(plottable,  NumOfAberrations, TypeOfAberration) %>%
  complete(NumOfAberrations, fill = list(n=0))

pB<-ggplot(plottable.c)+aes(x = factor(NumOfAberrations), y = n,fill = factor(NumOfAberrations)) +
  geom_col(position = position_dodge()) +
  geom_text(aes(label = n, y = n), vjust = -0.5, position = position_dodge(width=.9), size = 3)+
  facet_wrap(TypeOfAberration~., ncol = 1)+
  ggtitle("")+
  ylab("")+xlab("")+theme(axis.ticks.y = element_blank(),
        axis.text.y = element_blank())


ggarrange(pA, pB, ncol = 2, common.legend = T,legend = "bottom", widths = c(3,1) )
```


```{r,  echo=showcode, eval=runR,  fig.cap="We see that telocentric chromosomes (13, 14, 15, 21, 22) do not have data for chromosome arm aberrations, because they are counted as whole aneuploidies. Since we cannot differentiate between both kinds of aberration, we'll have to discard those chromosomess or analyze them apart from each other.", fig.width = 11, fig.asp = 1}
# To detect COUNT OUTLIERS in CHROMOSOMES
plottable.d<- count(plottable, chr,  NumOfAberrations, TypeOfAberration) %>% 
  complete(chr, NumOfAberrations, TypeOfAberration, fill = list(n = 0))

pC<-ggplot(plottable.d, aes(x = factor(chr), y = n, fill = factor(NumOfAberrations))) +
  geom_col(position = position_dodge()) +
  # geom_text(aes(label = n, y = n), vjust = -0.5, position = position_dodge(width=.9), size = 3)+
  facet_wrap(TypeOfAberration~., ncol = 1)+guides(fill = guide_legend(nrow = 1))+
  ggtitle("Distribution of aberrations among chromosomes")+
  ylab("")+xlab("Chromosome")+scale_fill_discrete(name = "Number of aberrations")


plottable.e<-count(plottable,NumOfAberrations, TypeOfAberration) %>%
  complete(NumOfAberrations, fill = list(n=0))

pD<-ggplot(plottable.e)+aes(x = factor(NumOfAberrations), y = n,fill = factor(NumOfAberrations)) +
  geom_col(position = position_dodge()) +
  geom_text(aes(label = n, y = n), vjust = -0.5, position = position_dodge(width=.9), size = 3)+
  facet_wrap(TypeOfAberration~., ncol = 1)+
  ggtitle("")+
  ylab("")+xlab("")+theme(axis.ticks.y = element_blank(),
        axis.text.y = element_blank())

ggarrange(plotlist= list(pC, pD), ncol = 2, common.legend = T,legend = "bottom", widths = c(3,1) )
```


```{r,  echo=showcode, eval=runR,  fig.cap="", fig.width = 11, fig.asp = 1}
####INVERSIONS
# To detect COUNT OUTLIERS in DONORS
plottable<-TestDataset.long[TestDataset.long$TypeOfAberration == "totalStructuralVariants",]

plottable.b<- count(plottable, donor,  Inv.count, InvSubset.count) %>% 
  complete(donor, Inv.count, InvSubset.count, fill = list(n = 0))

pA<-ggplot(plottable.b[plottable.b$donor!="all",], aes(x = factor(donor), y = n, fill = factor(Inv.count))) +
  geom_col(position = position_dodge()) +
  geom_text(aes(label = n, y = n), vjust = -0.5, position = position_dodge(width=.9), size = 3)+
  facet_wrap(InvSubset.count~., ncol = 1)+
  ggtitle("Distribution of inversions among donors")+
  ylab("")+xlab("Donor")+scale_fill_discrete(name = "Number of inversions")

plottable.c<-count(plottable, Inv.count, InvSubset.count) %>%
  complete(Inv.count, fill = list(n=0))

pB<-ggplot(plottable.c)+aes(x = factor(Inv.count), y = n,fill = factor(Inv.count)) +
  geom_col(position = position_dodge()) +
  geom_text(aes(label = n, y = n), vjust = -0.5, position = position_dodge(width=.9), size = 3)+
  facet_wrap(InvSubset.count~., ncol = 1)+
  ggtitle("")+
  ylab("")+xlab("")+theme(axis.ticks.y = element_blank(),
        axis.text.y = element_blank())

ggarrange(plotlist= list(pA, pB),ncol = 2, common.legend = T,legend = "bottom", widths = c(4,1) )
```


```{r,  echo=showcode, eval=runR,  fig.cap="", fig.width = 11, fig.asp = 1}
# To detect COUNT OUTLIERS in CHROMOSOMES
plottable<-TestDataset.long[TestDataset.long$TypeOfAberration == "totalStructuralVariants",]

plottable.d<- count(plottable, chr,  Inv.count, InvSubset.count) %>% 
  complete(chr, Inv.count, InvSubset.count, fill = list(n = 0))

pC<-ggplot(plottable.d, aes(x = factor(chr), y = n, fill = factor(Inv.count))) +
  geom_col(position = position_dodge()) +
  geom_text(aes(label = n, y = n), vjust = -0.5, position = position_dodge(width=.9), size = 3)+
  facet_wrap(InvSubset.count~., ncol = 1)+
  ggtitle("Distribution of inversions among chromosomes")+
  ylab("")+xlab("Chromosome")+scale_fill_discrete(name = "Number of inversions")

plottable.e<-count(plottable, Inv.count, InvSubset.count) %>%
  complete(Inv.count, fill = list(n=0))

pD<-ggplot(plottable.e)+aes(x = factor(Inv.count), y = n,fill = factor(Inv.count)) +
  geom_col(position = position_dodge()) +
  geom_text(aes(label = n, y = n), vjust = -0.5, position = position_dodge(width=.9), size = 3)+
  facet_wrap(InvSubset.count~., ncol = 1)+
  ggtitle("")+
  ylab("")+xlab("")+theme(axis.ticks.y = element_blank(),
        axis.text.y = element_blank())

ggarrange(plotlist= list(pC, pD), ncol = 2, common.legend = T,legend = "bottom", widths = c(4,1) )

```

```{r, echo = showcode, eval=runR}
rm(pA, pB, pC, pD, plottable, plottable.b, plottable.c, plottable.d, plottable.e)
```



## Determine outliers

As I mentioned before, chromosomes 13, 14, 15, 21 and 22 are telocentric and are not counted in the chromosome arm aberration dataset. 

### All chromosomes together

* chr9 is a structural variant outlier (for arm gains and losses as well)
* NC2 (arm losses)  and NC3 (arm gains) have more structural variants than expected for the number of cells analyzed.
* chr 1 and 16 are outliers for arm losses besides chr9
* NC25 is an inversion count outlier
* chr8 (and its carriers) are inversion length outliers
* chr7 and chr16 are inversion length outliers in the centromeric group 
* chr7 and 6 are length outliers within all inversions, besides chr8

```{r,  echo=showcode, eval=runR,  fig.cap="Scanning for aberration outliers", fig.width = 11, fig.asp = 1.2}
is_outlier <- function(x) {
  return(x < quantile(x, 0.25) - 1.5 * IQR(x) | x > quantile(x, 0.75) + 1.5 * IQR(x))
}

# CHROMOSOMES OUTSIDE DATASET
excludeChr<-c("chr13", "chr14", "chr15", "chr21", "chr22")
TestDataset$telocentric<-ifelse(TestDataset$chr %in% excludeChr, "Telocentric", "No-Telocentric")

#ABERRATIONS TO TEST
testAb<-c("totalStructuralVariants", "totalWholeAneuploidies", "totalArmLevelStructuralVariants", "totalArmLosses", "totalArmGains")
TestDataset.long.small<-TestDataset.long[TestDataset.long$TypeOfAberration %in% testAb,]
TestDataset.long.small$TypeOfAberration<-droplevels(TestDataset.long.small$TypeOfAberration)

# LIST OF POINT OUTLIERS for aberrations - and ind with more aberrations than expected for inspected cells
toPlot<-aggregate(NumOfAberrations ~ donor+ cells+TypeOfAberration, TestDataset.long.small[TestDataset.long.small$InvSubset.count == "count.all",], sum)
toPlot$AbFreq<-toPlot$NumOfAberrations / toPlot$cells
toPlot$outlier<-NA
for(t in testAb){
  toPlot[toPlot$TypeOfAberration == t, "outlier"] <- ifelse(is_outlier(toPlot[toPlot$TypeOfAberration == t, "AbFreq"]), as.character(toPlot[toPlot$TypeOfAberration == t, "donor"]), NA )
}
pA<-ggplot(toPlot, aes(y = NumOfAberrations, x  = cells))+geom_point(aes(color = donor))+geom_smooth(method = "lm")+facet_wrap(TypeOfAberration~., scales = "free", ncol = 1)+
  theme(legend.position = "none")+ggtitle("Correlation between \naberrations and # cells")
pB<-ggplot(toPlot, aes(y = NumOfAberrations/cells, x = "all"))+geom_boxplot(outlier.shape = NA)+
  geom_jitter(aes(color = donor), position = position_jitter(seed = 1, height = 0))+
  facet_wrap(TypeOfAberration~., scales = "free", ncol = 1)+
  geom_text(aes(label = outlier),position = position_jitter(seed = 1, height = 0), size = 3 ,hjust = -0.5)+
  theme(legend.position = "none")+ggtitle("Aberration Frequency \ndonor outliers")

# LIST OF POINT OUTLIERS for aberrations - a chr with more aberrations than expected 
toPlot<-aggregate(NumOfAberrations ~ chr+ TypeOfAberration, TestDataset.long.small[TestDataset.long.small$InvSubset.count == "count.all",], sum)
toPlot$outlier<-NA
for(t in testAb){
  toPlot[toPlot$TypeOfAberration == t, "outlier"] <- ifelse(is_outlier(toPlot[toPlot$TypeOfAberration == t, "NumOfAberrations"]), as.character(toPlot[toPlot$TypeOfAberration == t, "chr"]), NA )
}
pC<-ggplot(toPlot, aes(y = NumOfAberrations, x = "all"))+
  geom_boxplot(outlier.shape = NA)+
  geom_jitter(aes(color = chr), position = position_jitter(seed = 1))+
  facet_wrap(TypeOfAberration~., scales = "free", ncol = 1)+
  geom_text(aes(label = outlier),position = position_jitter(seed = 1, height = 0), size = 3,  hjust = -0.5)+
  theme(legend.position = "none")+ggtitle("Aberration number\nchr outliers")

ggarrange(pA, pB, pC, nrow = 1,  widths = c(1,1,1) )
```


```{r,  echo=showcode, eval=runR,  fig.cap="Scanning for inversion count outliers", fig.width = 11, fig.asp = 1.2}
#NOW OUTLIERS IN IVNERSION COUNT 

# LIST OF POINT OUTLIERS for inversion count - and ind with more invs than expected 
toPlot<-aggregate(Inv.count ~ donor+InvSubset.count, TestDataset.long.small[TestDataset.long.small$TypeOfAberration == "totalStructuralVariants",], sum)
toPlot$outlier<-NA

  for(i in levels(toPlot$InvSubset.count)){
  toPlot[ toPlot$InvSubset.count == i, "outlier"] <- ifelse(is_outlier(toPlot[ toPlot$InvSubset.count == i, "Inv.count"]), as.character(toPlot[ toPlot$InvSubset.count == i, "donor"]), NA )
  }


pA<-ggplot(toPlot, aes(y = Inv.count, x = "all"))+geom_boxplot(outlier.shape = NA)+
  geom_jitter(aes(color = donor), position = position_jitter(seed = 1, height = 0))+
  facet_wrap(InvSubset.count~., scales = "free", ncol = 1)+
  geom_text(aes(label = outlier),position = position_jitter(seed = 1, height = 0), size = 3 ,hjust = -0.5)+
  theme(legend.position = "none")+ggtitle("HET inversion total count \ndonor outliers")

# LIST OF POINT OUTLIERS for aberrations - a chr with more aberrations than expected 
toPlot<-aggregate(Inv.count ~ chr+InvSubset.count, TestDataset.long.small[TestDataset.long.small$TypeOfAberration == "totalStructuralVariants",], sum)
toPlot$outlier<-NA

  for(i in levels(toPlot$InvSubset.count)){
  toPlot[ toPlot$InvSubset.count == i, "outlier"] <- ifelse(is_outlier(toPlot[toPlot$InvSubset.count == i, "Inv.count"]), as.character(toPlot[ toPlot$InvSubset.count == i, "chr"]), NA )
  }

pB<-ggplot(toPlot, aes(y = Inv.count, x = "all"))+
  geom_boxplot(outlier.shape = NA)+
  geom_jitter(aes(color = chr), position = position_jitter(seed = 1, height = 0))+
    facet_wrap(InvSubset.count~., scales = "free", ncol = 1)+
  geom_text(aes(label = outlier),position = position_jitter(seed = 1, height = 0), size = 3,  hjust = -0.5)+
  theme(legend.position = "none")+ggtitle("HET inversion total count \nchr outliers")

#Now without the empty cases
toPlot<-toPlot[which(toPlot$InvSubset.count == "count.all" | (toPlot$InvSubset.count != "count.all" & toPlot$Inv.count != 0)),]
toPlot$outlier<-NA

  for(i in levels(toPlot$InvSubset.count)){
  toPlot[ toPlot$InvSubset.count == i, "outlier"] <- ifelse(is_outlier(toPlot[toPlot$InvSubset.count == i, "Inv.count"]), as.character(toPlot[ toPlot$InvSubset.count == i, "chr"]), NA )
  }
pC<-ggplot(toPlot, aes(y = Inv.count, x = "all"))+
  geom_boxplot(outlier.shape = NA)+
  geom_jitter(aes(color = chr), position = position_jitter(seed = 1, height = 0))+
    facet_wrap(InvSubset.count~., scales = "free", ncol = 1)+
  geom_text(aes(label = outlier),position = position_jitter(seed = 1, height = 0), size = 3,  hjust = -0.5)+
  theme(legend.position = "none")+ggtitle("HET inversion total count \nchr (w/o 0 cases) outliers ")

ggarrange(pA, pB, pC, nrow = 1,  widths = c(1,1,1) )
```


```{r,  echo=showcode, eval=runR,  fig.cap="Scanning for inversion length sum outliers", fig.width = 11, fig.asp = 1.2}

#NOW OUTLIERS IN IVNERSION COUNT 


# LIST OF POINT OUTLIERS for inversion count - and ind with more invs than expected 
toPlot<-aggregate(cM.Mb.sum ~ donor+InvSubset.count, TestDataset.long.small[TestDataset.long.small$TypeOfAberration == "totalStructuralVariants",], sum)
toPlot$outlier<-NA

  for(i in levels(toPlot$InvSubset.count)){
  toPlot[ toPlot$InvSubset.count == i, "outlier"] <- ifelse(is_outlier(toPlot[ toPlot$InvSubset.count == i, "cM.Mb.sum"]), as.character(toPlot[ toPlot$InvSubset.count == i, "donor"]), NA )
  }


pA<-ggplot(toPlot, aes(y = cM.Mb.sum, x = "all"))+geom_boxplot(outlier.shape = NA)+
  geom_jitter(aes(color = donor), position = position_jitter(seed = 1, height = 0))+
  facet_wrap(InvSubset.count~., scales = "free", ncol = 1)+
  geom_text(aes(label = outlier),position = position_jitter(seed = 1, height = 0), size = 3 ,hjust = -0.5)+
  theme(legend.position = "none")+ggtitle("HET inversion length sum \ndonor outliers")

# LIST OF POINT OUTLIERS for aberrations - a chr with more aberrations than expected 
toPlot<-aggregate(cM.Mb.sum ~ chr+InvSubset.count, TestDataset.long.small[TestDataset.long.small$TypeOfAberration == "totalStructuralVariants",], sum)
toPlot$outlier<-NA

  for(i in levels(toPlot$InvSubset.count)){
  toPlot[ toPlot$InvSubset.count == i, "outlier"] <- ifelse(is_outlier(toPlot[toPlot$InvSubset.count == i, "cM.Mb.sum"]), as.character(toPlot[ toPlot$InvSubset.count == i, "chr"]), NA )
  }

pB<-ggplot(toPlot, aes(y = cM.Mb.sum, x = "all"))+
  geom_boxplot(outlier.shape = NA)+
  geom_jitter(aes(color = chr), position = position_jitter(seed = 1, height = 0))+
    facet_wrap(InvSubset.count~., scales = "free", ncol = 1)+
  geom_text(aes(label = outlier),position = position_jitter(seed = 1, height = 0), size = 3,  hjust = -0.5)+
  theme(legend.position = "none")+ggtitle("HET inversion length sum \nchr outliers")

#Now without the empty cases
toPlot<-toPlot[which(toPlot$InvSubset.count == "count.all" | (toPlot$InvSubset.count != "count.all" & toPlot$cM.Mb.sum != 0)),]
toPlot$outlier<-NA

  for(i in levels(toPlot$InvSubset.count)){
  toPlot[ toPlot$InvSubset.count == i, "outlier"] <- ifelse(is_outlier(toPlot[toPlot$InvSubset.count == i, "cM.Mb.sum"]), as.character(toPlot[ toPlot$InvSubset.count == i, "chr"]), NA )
  }
pC<-ggplot(toPlot, aes(y = cM.Mb.sum, x = "all"))+
  geom_boxplot(outlier.shape = NA)+
  geom_jitter(aes(color = chr), position = position_jitter(seed = 1, height = 0))+
    facet_wrap(InvSubset.count~., scales = "free", ncol = 1)+
  geom_text(aes(label = outlier),position = position_jitter(seed = 1, height = 0), size = 3,  hjust = -0.5)+
  theme(legend.position = "none")+ggtitle("HET inversion length sum \nchr (w/o 0 cases) outliers ")

ggarrange(pA, pB, pC, nrow = 1,  widths = c(1,1,1) )


```



### Without the telocentric chromosomes


* chr9 is a structural variant outlier (for arm gains and losses as well), chr1 is a chromosome arm loss outlier
* NC25 is an inversion count outlier, NC6 is an outlier but for a low inversion count
* chr8 (and its carriers NC1, NC15, NC14) are inversion length outliers, in addition NC18 is a centromeric inv length outlier and NC22 a telomeric inv length outlier
* chr7 and chr16 are inversion length outliers in the centromeric group 
* chr7 and  length outlier within all inversions, besides chr8

```{r,  echo=showcode, eval=runR,  fig.cap="Scanning for aberration outliers", fig.width = 11, fig.asp = 1.2}
is_outlier <- function(x) {
  x[x %in% c(Inf, -Inf)]<-NA
  return(x < quantile(x, 0.25, na.rm = T) - 1.5 * IQR(x, na.rm = T) | x > quantile(x, 0.75, na.rm = T) + 1.5 * IQR(x, na.rm = T))
}

# CHROMOSOMES OUTSIDE DATASET
excludeChr<-c("chr13", "chr14", "chr15", "chr21", "chr22")
TestDataset$telocentric<-ifelse(TestDataset$chr %in% excludeChr, "Telocentric", "No-Telocentric")
TestDataset.long$telocentric<-ifelse(TestDataset.long$chr %in% excludeChr, "Telocentric", "No-Telocentric")
TestDataset.long.saved<-TestDataset.long
TestDataset.long<-TestDataset.long[TestDataset.long$telocentric == "No-Telocentric",]
TestDataset.long$chr<-droplevels(TestDataset.long$chr)


#ABERRATIONS TO TEST
testAb<-c("totalStructuralVariants", "totalWholeAneuploidies", "totalArmLevelStructuralVariants", "totalArmLosses", "totalArmGains")
TestDataset.long.small<-TestDataset.long[TestDataset.long$TypeOfAberration %in% testAb,]
TestDataset.long.small$TypeOfAberration<-droplevels(TestDataset.long.small$TypeOfAberration)

# LIST OF POINT OUTLIERS for aberrations - and ind with more aberrations than expected for inspected cells
toPlot<-aggregate(NumOfAberrations ~ donor+ cells+TypeOfAberration, TestDataset.long.small[TestDataset.long.small$InvSubset.count == "count.all",], sum)
toPlot$AbFreq<-toPlot$NumOfAberrations / toPlot$cells
toPlot$outlier<-NA
for(t in testAb){
  toPlot[toPlot$TypeOfAberration == t, "outlier"] <- ifelse(is_outlier(toPlot[toPlot$TypeOfAberration == t, "AbFreq"]), as.character(toPlot[toPlot$TypeOfAberration == t, "donor"]), NA )
}
pA<-ggplot(toPlot, aes(y = NumOfAberrations, x  = cells))+geom_point(aes(color = donor))+geom_smooth(method = "lm")+facet_wrap(TypeOfAberration~., scales = "free", ncol = 1)+
  theme(legend.position = "none")+ggtitle("Correlation between \naberrations and # cells")
pB<-ggplot(toPlot, aes(y = NumOfAberrations/cells, x = "all"))+geom_boxplot(outlier.shape = NA)+
  geom_jitter(aes(color = donor), position = position_jitter(seed = 1, height = 0))+
  facet_wrap(TypeOfAberration~., scales = "free", ncol = 1)+
  geom_text(aes(label = outlier),position = position_jitter(seed = 1, height = 0), size = 3 ,hjust = -0.5)+
  theme(legend.position = "none")+ggtitle("Aberration Frequency \ndonor outliers")

# LIST OF POINT OUTLIERS for aberrations - a chr with more aberrations than expected 
toPlot<-aggregate(NumOfAberrations ~ chr+ TypeOfAberration, TestDataset.long.small[TestDataset.long.small$InvSubset.count == "count.all",], sum)
toPlot$outlier<-NA
for(t in testAb){
  toPlot[toPlot$TypeOfAberration == t, "outlier"] <- ifelse(is_outlier(toPlot[toPlot$TypeOfAberration == t, "NumOfAberrations"]), as.character(toPlot[toPlot$TypeOfAberration == t, "chr"]), NA )
}
pC<-ggplot(toPlot, aes(y = NumOfAberrations, x = "all"))+
  geom_boxplot(outlier.shape = NA)+
  geom_jitter(aes(color = chr), position = position_jitter(seed = 1))+
  facet_wrap(TypeOfAberration~., scales = "free", ncol = 1)+
  geom_text(aes(label = outlier),position = position_jitter(seed = 1, height = 0), size = 3,  hjust = -0.5)+
  theme(legend.position = "none")+ggtitle("Aberration number\nchr outliers")

ggarrange(pA, pB, pC, nrow = 1,  widths = c(1,1,1) )
```


```{r,  echo=showcode, eval=runR,  fig.cap="Scanning for inversion count outliers", fig.width = 11, fig.asp = 1.2}
#NOW OUTLIERS IN IVNERSION COUNT 

# LIST OF POINT OUTLIERS for inversion count - and ind with more invs than expected 
toPlot<-aggregate(Inv.count ~ donor+InvSubset.count, TestDataset.long.small[TestDataset.long.small$TypeOfAberration == "totalStructuralVariants",], sum)
toPlot$outlier<-NA

  for(i in levels(toPlot$InvSubset.count)){
  toPlot[ toPlot$InvSubset.count == i, "outlier"] <- ifelse(is_outlier(toPlot[ toPlot$InvSubset.count == i, "Inv.count"]), as.character(toPlot[ toPlot$InvSubset.count == i, "donor"]), NA )
  }


pA<-ggplot(toPlot, aes(y = Inv.count, x = "all"))+geom_boxplot(outlier.shape = NA)+
  geom_jitter(aes(color = donor), position = position_jitter(seed = 1, height = 0))+
  facet_wrap(InvSubset.count~., scales = "free", ncol = 1)+
  geom_text(aes(label = outlier),position = position_jitter(seed = 1, height = 0), size = 3 ,hjust = -0.5)+
  theme(legend.position = "none")+ggtitle("HET inversion total count \ndonor outliers")

# LIST OF POINT OUTLIERS for aberrations - a chr with more aberrations than expected 
toPlot<-aggregate(Inv.count ~ chr+InvSubset.count, TestDataset.long.small[TestDataset.long.small$TypeOfAberration == "totalStructuralVariants",], sum)
toPlot$outlier<-NA

  for(i in levels(toPlot$InvSubset.count)){
  toPlot[ toPlot$InvSubset.count == i, "outlier"] <- ifelse(is_outlier(toPlot[toPlot$InvSubset.count == i, "Inv.count"]), as.character(toPlot[ toPlot$InvSubset.count == i, "chr"]), NA )
  }

pB<-ggplot(toPlot, aes(y = Inv.count, x = "all"))+
  geom_boxplot(outlier.shape = NA)+
  geom_jitter(aes(color = chr), position = position_jitter(seed = 1, height = 0))+
    facet_wrap(InvSubset.count~., scales = "free", ncol = 1)+
  geom_text(aes(label = outlier),position = position_jitter(seed = 1, height = 0), size = 3,  hjust = -0.5)+
  theme(legend.position = "none")+ggtitle("HET inversion total count \nchr outliers")

#Now without the empty cases
toPlot<-toPlot[which(toPlot$InvSubset.count == "count.all" | (toPlot$InvSubset.count != "count.all" & toPlot$Inv.count != 0)),]
toPlot$outlier<-NA

  for(i in levels(toPlot$InvSubset.count)){
  toPlot[ toPlot$InvSubset.count == i, "outlier"] <- ifelse(is_outlier(toPlot[toPlot$InvSubset.count == i, "Inv.count"]), as.character(toPlot[ toPlot$InvSubset.count == i, "chr"]), NA )
  }
pC<-ggplot(toPlot, aes(y = Inv.count, x = "all"))+
  geom_boxplot(outlier.shape = NA)+
  geom_jitter(aes(color = chr), position = position_jitter(seed = 1, height = 0))+
    facet_wrap(InvSubset.count~., scales = "free", ncol = 1)+
  geom_text(aes(label = outlier),position = position_jitter(seed = 1, height = 0), size = 3,  hjust = -0.5)+
  theme(legend.position = "none")+ggtitle("HET inversion total count \nchr (w/o 0 cases) outliers ")

ggarrange(pA, pB, pC, nrow = 1,  widths = c(1,1,1) )
```


```{r,  echo=showcode, eval=runR,  fig.cap="Scanning for inversion length sum outliers", fig.width = 11, fig.asp = 1.2}
#NOW OUTLIERS IN IVNERSION COUNT 


# LIST OF POINT OUTLIERS for inversion count - and ind with more invs than expected 
toPlot<-aggregate(cM.Mb.sum ~ donor+InvSubset.count, TestDataset.long.small[TestDataset.long.small$TypeOfAberration == "totalStructuralVariants",], sum)
toPlot$outlier<-NA

  for(i in levels(toPlot$InvSubset.count)){
  toPlot[ toPlot$InvSubset.count == i, "outlier"] <- ifelse(is_outlier(toPlot[ toPlot$InvSubset.count == i, "cM.Mb.sum"]), as.character(toPlot[ toPlot$InvSubset.count == i, "donor"]), NA )
  }


pA<-ggplot(toPlot, aes(y = cM.Mb.sum, x = "all"))+geom_boxplot(outlier.shape = NA)+
  geom_jitter(aes(color = donor), position = position_jitter(seed = 1, height = 0))+
  facet_wrap(InvSubset.count~., scales = "free", ncol = 1)+
  geom_text(aes(label = outlier),position = position_jitter(seed = 1, height = 0), size = 3 ,hjust = -0.5)+
  theme(legend.position = "none")+ggtitle("HET inversion length sum \ndonor outliers")

# LIST OF POINT OUTLIERS for aberrations - a chr with more aberrations than expected 
toPlot<-aggregate(cM.Mb.sum ~ chr+InvSubset.count, TestDataset.long.small[TestDataset.long.small$TypeOfAberration == "totalStructuralVariants",], sum)
toPlot$outlier<-NA

  for(i in levels(toPlot$InvSubset.count)){
  toPlot[ toPlot$InvSubset.count == i, "outlier"] <- ifelse(is_outlier(toPlot[toPlot$InvSubset.count == i, "cM.Mb.sum"]), as.character(toPlot[ toPlot$InvSubset.count == i, "chr"]), NA )
  }

pB<-ggplot(toPlot, aes(y = cM.Mb.sum, x = "all"))+
  geom_boxplot(outlier.shape = NA)+
  geom_jitter(aes(color = chr), position = position_jitter(seed = 1, height = 0))+
    facet_wrap(InvSubset.count~., scales = "free", ncol = 1)+
  geom_text(aes(label = outlier),position = position_jitter(seed = 1, height = 0), size = 3,  hjust = -0.5)+
  theme(legend.position = "none")+ggtitle("HET inversion length sum \nchr outliers")

#Now without the empty cases
toPlot<-toPlot[which(toPlot$InvSubset.count == "count.all" | (toPlot$InvSubset.count != "count.all" & toPlot$cM.Mb.sum != 0)),]
toPlot$outlier<-NA

  for(i in levels(toPlot$InvSubset.count)){
  toPlot[ toPlot$InvSubset.count == i, "outlier"] <- ifelse(is_outlier(toPlot[toPlot$InvSubset.count == i, "cM.Mb.sum"]), as.character(toPlot[ toPlot$InvSubset.count == i, "chr"]), NA )
  }
pC<-ggplot(toPlot, aes(y = cM.Mb.sum, x = "all"))+
  geom_boxplot(outlier.shape = NA)+
  geom_jitter(aes(color = chr), position = position_jitter(seed = 1, height = 0))+
    facet_wrap(InvSubset.count~., scales = "free", ncol = 1)+
  geom_text(aes(label = outlier),position = position_jitter(seed = 1, height = 0), size = 3,  hjust = -0.5)+
  theme(legend.position = "none")+ggtitle("HET inversion length sum \nchr (w/o 0 cases) outliers ")

ggarrange(pA, pB, pC, nrow = 1,  widths = c(1,1,1) )
```


```{r,  echo=showcode, eval=runR,  fig.cap="Scanning for general outliers", fig.width = 11, fig.asp = 1.2}


# LIST OF POINT OUTLIERS for inversion count - and ind with more invs than expected 
toPlot<-TestDataset.long.small[TestDataset.long.small$TypeOfAberration == "totalStructuralVariants",]
toPlot<-toPlot[which(toPlot$InvSubset.count == "count.all" | (toPlot$InvSubset.count != "count.all" & toPlot$cM.Mb.sum != 0)),]
toPlot$outlier<-NA


  for(i in levels(toPlot$InvSubset.count)){
  toPlot[ toPlot$InvSubset.count == i, "outlier"] <- ifelse(is_outlier((toPlot[ toPlot$InvSubset.count == i, "Inv.count"])), paste( as.character(toPlot[ toPlot$InvSubset.count == i, c("donor")]),  as.character(toPlot[ toPlot$InvSubset.count == i, c("chr")]), sep =","), NA )
  }


pA<-ggplot(toPlot, aes(y = (Inv.count), x = TypeOfAberration))+geom_boxplot(outlier.shape = NA)+
  geom_jitter(aes(color = donor), position = position_jitter(seed = 1, height = 0.2, width = 3))+
  facet_grid(InvSubset.count~.)+
  geom_text(aes(label = outlier),position = position_jitter(seed = 1, height = 0.2, width = 3), size = 3 ,hjust = -0.2)+
  ggtitle("General inv count  outliers")

# LIST OF POINT OUTLIERS for inversion count - and ind with more invs than expected 
toPlot<-TestDataset.long.small[TestDataset.long.small$InvSubset.count == "count.all",]
# toPlot<-toPlot[which(toPlot$InvSubset.count == "count.all" | (toPlot$InvSubset.count != "count.all" & toPlot$cM.Mb.sum != 0)),]
toPlot$outlier<-NA


  for(i in levels(toPlot$TypeOfAberration)){
  toPlot[ toPlot$TypeOfAberration == i, "outlier"] <- ifelse(is_outlier(log10(toPlot[ toPlot$TypeOfAberration == i, "NumOfAberrations"])), paste( as.character(toPlot[ toPlot$TypeOfAberration == i, c("donor")]),  as.character(toPlot[ toPlot$TypeOfAberration == i, c("chr")]), sep =","), NA )
  }


pB<-ggplot(toPlot, aes(y = (NumOfAberrations), x = InvSubset.count))+geom_boxplot(outlier.shape = NA)+
  geom_jitter(aes(color = donor), position = position_jitter(seed = 2, height = 0))+
  facet_grid(TypeOfAberration~.)+
  geom_text(aes(label = outlier),position = position_jitter(seed = 2, height = 0), size = 3 ,hjust = -0.2)+
  ggtitle("General ab count  outliers")


```





## Inversions vs. aberrations, exploratory analysis

```{r testFunction,  echo=showcode, eval=runR}


makeSquareTest<-function(xvar, yvar, namex, namey){
  # table(xvar, yvar)
  perc<-as.data.frame(table(xvar, yvar))
  perc$percent<-apply(perc, 1, function(x){
    as.numeric(x["Freq"]) / sum( perc[perc$xvar == x["xvar"], "Freq"] ) 
    })
  perc$Label<-paste0("N = ", perc$Freq, " (",round(perc$percent*100, 2), "%)")
  
  c<-chisq.test(xvar, yvar)
  f<-fisher.test(xvar, yvar)
  
  statMessage<- paste0("Fisher's Exact Test", ", p-value = ", round(f$p.value, 4 ), "\n","Chi-sq", ", p-value = ", round(c$p.value, 4 ))
  
  ggplot(perc, aes(x = xvar, y = Freq, fill = yvar, label = Label ))+
    geom_bar(position ="fill", stat="identity")+
    geom_text( size = 3, position = position_fill(vjust=0.5))+
    theme(  legend.position = "bottom")+ 
    ylab("")+xlab("")+
    labs(title = paste0(namex," vs. ", namey), subtitle= statMessage)
  

}
```


```{r armGains,  echo=showcode, eval=runR,fig.cap="Analysis for the relationship between inversions and aberrations" ,  fig.height=8}
# ARM GAINS vs all kinds of invsT
plotlist<-list()
for(invType in unique(TestDataset.long$InvSubset.sum)){
  for(aberrationType in c("totalWholeAneuploidies", "totalArmLevelStructuralVariants", "totalArmLosses", "totalArmGains")){
    plotlist[[paste0(invType,aberrationType)]]<- makeSquareTest(ifelse(TestDataset[,invType] == 0, "NoInvs", "Invs"),  # xvar
                   ifelse(TestDataset[,aberrationType] == 0, "NoAberration", "Aberration"),  # yvar
                 invType, aberrationType) # names
}
}


# do.call("grid.arrange", c(plotlist))
ggarrange(plotlist=plotlist, common.legend = TRUE, legend = "bottom")
```

```{r}
pacman::p_load(GGally)

# Setup corrplot
  diagonal <- function(data, mapping, ...){
    p<-ggplot(data=data, mapping = mapping)+
      geom_histogram(aes(y= ..density..), bins = 9, fill = "lightgray", color = "gray")+
      geom_density()
  }

 lines <- function(data, mapping, ...){
    p<-ggplot(data=data, mapping = mapping)+
      geom_smooth(method=lm, alpha=0)+
      geom_point(size=0.5)
 }
 
ggpairs(TestDataset[,c("cM.QN.sum.all", "count.all")],
        lower = list(continuous = lines),
              diag = list(continuous = diagonal), 
              upper = list(continuous = wrap("cor", method = "pearson", size = 3)))+
   ggtitle("Pearson correlation")+theme(axis.text.x = element_text(angle = 45, hjust = 1))+
   scale_fill_manual(values=c("#00AFBB", "#E7B800", "#FC4E07")) +scale_color_manual(values=c("#00AFBB", "#E7B800", "#FC4E07"))  


# They are not correlated so I'll analyze them separately
# SUMS
ab<- c("totalWholeAneuploidies", "totalArmLevelStructuralVariants", "totalArmLosses", "totalArmGains")
inv<-   as.character(unique(TestDataset.long$InvSubset.sum))
ggduo(
  TestDataset[,c(ab, inv)],inv,ab,
  types = list(continuous = "smooth_lm"),
  title = "Between Structural Vars and HET centiMorgan Vars Correlation",
  ylab = "Structural Vars",
  xlab = "HET cM Vars"
)

# COUNTS
ab<- c("totalWholeAneuploidies", "totalArmLevelStructuralVariants", "totalArmLosses", "totalArmGains")
inv<-   as.character(unique(TestDataset.long$InvSubset.count))
ggduo(
  TestDataset[,c(ab, inv)],inv,ab,
  types = list(continuous = "smooth_lm"),
  title = "Between Structural Vars and HET centiMorgan Vars Correlation",
  ylab = "Structural Vars",
  xlab = "HET counts Vars"
)
# ONLY POSITIVES

# They are not correlated so I'll analyze them separately
# SUMS
TestDataset.long$InvPresence<-ifelse(TestDataset.long$Inv.count > 0, "WithInvs", "WithoutInvs")
ggplot(TestDataset.long[which((TestDataset.long$TypeOfAberration %in% ab )& TestDataset.long$InvPresence == "WithInvs" & TestDataset.long$NumOfAberrations >0 & TestDataset.long$InvSubset.sum == "cM.QN.sum.all"),],
       aes(y = log10(NumOfAberrations), x = log10(cM.Mb.sum)  ))+
  geom_point()+geom_smooth(method = "lm")+
  facet_grid(TypeOfAberration ~ .  )
```



## Inversions vs. aberrations, advanced analysis

```{r testFunction,  echo=showcode, eval=runR}


makeSquareTest<-function(xvar, yvar, namex, namey){
  # table(xvar, yvar)
  perc<-as.data.frame(table(xvar, yvar))
  perc$percent<-apply(perc, 1, function(x){
    as.numeric(x["Freq"]) / sum( perc[perc$xvar == x["xvar"], "Freq"] ) 
    })
  perc$Label<-paste0("N = ", perc$Freq, " (",round(perc$percent*100, 2), "%)")
  
  c<-chisq.test(xvar, yvar)
  f<-fisher.test(xvar, yvar)
  
  statMessage<- paste0(f$method, ", p-value = ", round(f$p.value, 4 ), "\n",c$method, ", p-value = ", round(c$p.value, 4 ))
  
  ggplot(perc, aes(x = xvar, y = Freq, fill = yvar, label = Label ))+
    geom_bar(position ="fill", stat="identity")+
    geom_text( size = 3, position = position_fill(vjust=0.5))+
    theme(  legend.position = "bottom", plot.subtitle = element_text(size = 7))+ 
    ylab("")+xlab("")+
    labs(title = paste0(namex," vs. ", namey), subtitle= statMessage)
  

}
```



```{r}

TestDataset.saved<-TestDataset
```


```{r}

TestDataset.long.saved$yvar<-TestDataset.long.saved$NumOfAberrations / TestDataset.long.saved$cells

TestDataset.long<-TestDataset.long.saved[TestDataset.long.saved$TypeOfAberration %in% testAb,]

# Simple
ggplot(TestDataset.long, aes(x = cM.Mb.sum, y = NumOfAberrations/cells))+geom_point ()+ geom_smooth(method = "lm")+facet_wrap(TypeOfAberration ~ InvSubset.sum, scales = "free", ncol = 4)

#Without telocentric
ggplot(TestDataset.long[TestDataset.long$telocentric != "Telocentric",], aes(x = cM.Mb.sum, y = NumOfAberrations/cells))+geom_point ()+ geom_smooth(method = "lm")+facet_wrap(TypeOfAberration ~ InvSubset.sum, scales = "free", ncol = 4)



```


```{r}
TestDataset<-TestDataset.saved[TestDataset.saved$telocentric == "No-Telocentric"& TestDataset.saved$chr != "chr9" ,]

# ARM GAINS vs all kinds of invsT
plotlist<-list()
for(invType in unique(TestDataset.long$InvSubset.count)){
  for(aberrationType in c("totalWholeAneuploidies", "totalArmLevelStructuralVariants", "totalArmLosses", "totalArmGains")){
    plotlist[[paste0(invType,aberrationType)]]<- makeSquareTest(ifelse(TestDataset[,invType] == 0, "NoInvs", "Invs"),  # xvar
                   ifelse(TestDataset[,aberrationType] == 0, "NoAberration", "Aberration"),  # yvar
                 invType, aberrationType) # names
}
}


# do.call("grid.arrange", c(plotlist))
ggarrange(plotlist=plotlist, common.legend = TRUE, legend = "bottom")
#
TestDataset<-TestDataset.saved[TestDataset.saved$telocentric == "Telocentric" ,]

# ARM GAINS vs all kinds of invsT
plotlist<-list()
for(invType in unique(TestDataset.long$InvSubset.count)){
  for(aberrationType in c("totalWholeAneuploidies", "totalArmLevelStructuralVariants", "totalArmLosses", "totalArmGains")){
    plotlist[[paste0(invType,aberrationType)]]<- makeSquareTest(ifelse(TestDataset[,invType] == 0, "NoInvs", "Invs"),  # xvar
                   ifelse(TestDataset[,aberrationType] == 0, "NoAberration", "Aberration"),  # yvar
                 invType, aberrationType) # names
}
}


# do.call("grid.arrange", c(plotlist))
ggarrange(plotlist=plotlist, common.legend = TRUE, legend = "bottom")

```


```{r}
#---- liear

m<-lm(totalArmLosses ~  cells+ xperchr+crossovers+ count.all+ cM.QN.sum.all+ count.centro+ cM.QN.sum.centro , TestDataset[TestDataset$telocentric == "No-Telocentric" ,])
summary(m)

performance::check_model(m)

#-------

TestDataset.plot<-TestDataset.long[!(TestDataset.long$chr %in% c("chr13", "chr14", "chr15", "chr21", "chr22")), ]

TestDataset.plot$AberratoinFreq<-with(TestDataset.plot, NumOfAberrations/cells)
ggplot(TestDataset.plot, aes(y = AberratoinFreq, x = cM.Mb.sum))+geom_point()+geom_smooth(method = "lm")+stat_cor(method = "spearman")+
  facet_grid(TypeOfAberration ~ InvSubset.sum, scales = "free")
```



# Discussion

The big inversions and the telomeric inversions subsets raised a warning because they did not have enough sample size to use a Chi-squared test, although there wasn't any significant result from the Fisher's exact test for these subsets either.

When considering all inversions together, chromosomes with heterozygous inversions have significantly more arm losses, which is consistent with the fact that any crossover between opposite orientations will generate an acentric that is lost, so there is always less genetic material than usual in the resulting chromosomes. 

Centromeric inversions in heterozygosis are significantly associated to both arm losses and arm gains. The relationship with arm losses was expected, but I do not understand where do arm gains come from, unless there are cases in which the dicentric does not break.

Finding an increase in aberrations related to the presence of inversions in heterozygosis is consistent with the purifying selection theory and with other experiments regarding this same question. 